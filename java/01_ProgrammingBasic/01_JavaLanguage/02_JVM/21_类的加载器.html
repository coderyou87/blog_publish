<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类的加载器 | coder</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon1" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-02-18/d687f535b564447e82a3178a4e9b2f8c.jpg">
    <link rel="icon2" href="https://you-blog.oss-cn-shenzhen.aliyuncs.com/typora/2021-02-18/icon.jpg">
    <script src="/css/jquery.slim.min.js"></script>
    <script src="/css/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css">
    <meta name="description" content="知行合一">
    <link rel="preload" href="/assets/css/0.styles.76271d17.css" as="style"><link rel="preload" href="/assets/js/app.ba474f6b.js" as="script"><link rel="preload" href="/assets/js/2.92f2819f.js" as="script"><link rel="preload" href="/assets/js/49.6417fcf5.js" as="script"><link rel="prefetch" href="/assets/js/10.b8e98ea8.js"><link rel="prefetch" href="/assets/js/100.c91f48ac.js"><link rel="prefetch" href="/assets/js/101.25da26dd.js"><link rel="prefetch" href="/assets/js/102.5241a842.js"><link rel="prefetch" href="/assets/js/103.30ac13f6.js"><link rel="prefetch" href="/assets/js/104.c36e99ea.js"><link rel="prefetch" href="/assets/js/105.0b04cb0d.js"><link rel="prefetch" href="/assets/js/106.8a6d905c.js"><link rel="prefetch" href="/assets/js/107.13ab2151.js"><link rel="prefetch" href="/assets/js/108.9f0fe2b0.js"><link rel="prefetch" href="/assets/js/109.80d909a3.js"><link rel="prefetch" href="/assets/js/11.dece430d.js"><link rel="prefetch" href="/assets/js/110.1229c377.js"><link rel="prefetch" href="/assets/js/111.be5d98db.js"><link rel="prefetch" href="/assets/js/112.9a42977b.js"><link rel="prefetch" href="/assets/js/113.63070a5c.js"><link rel="prefetch" href="/assets/js/114.7662291d.js"><link rel="prefetch" href="/assets/js/115.aa4e5a63.js"><link rel="prefetch" href="/assets/js/116.22632cb4.js"><link rel="prefetch" href="/assets/js/117.448e175a.js"><link rel="prefetch" href="/assets/js/118.2b5a0043.js"><link rel="prefetch" href="/assets/js/119.d1a92d45.js"><link rel="prefetch" href="/assets/js/12.c0cbcc4a.js"><link rel="prefetch" href="/assets/js/120.71489ff3.js"><link rel="prefetch" href="/assets/js/121.986f735c.js"><link rel="prefetch" href="/assets/js/122.9aaa801a.js"><link rel="prefetch" href="/assets/js/123.372fd139.js"><link rel="prefetch" href="/assets/js/124.0c502dc1.js"><link rel="prefetch" href="/assets/js/125.4ffcf33c.js"><link rel="prefetch" href="/assets/js/126.fa2b235d.js"><link rel="prefetch" href="/assets/js/127.bb92d209.js"><link rel="prefetch" href="/assets/js/128.e6f2f2f8.js"><link rel="prefetch" href="/assets/js/129.4efba7d9.js"><link rel="prefetch" href="/assets/js/13.3e1fee42.js"><link rel="prefetch" href="/assets/js/130.91758720.js"><link rel="prefetch" href="/assets/js/131.a16cff2a.js"><link rel="prefetch" href="/assets/js/132.4397af00.js"><link rel="prefetch" href="/assets/js/133.4617d3fe.js"><link rel="prefetch" href="/assets/js/134.84e29cf4.js"><link rel="prefetch" href="/assets/js/135.f2be934a.js"><link rel="prefetch" href="/assets/js/136.7455212a.js"><link rel="prefetch" href="/assets/js/137.51f8a051.js"><link rel="prefetch" href="/assets/js/138.15129d2d.js"><link rel="prefetch" href="/assets/js/139.b4031d29.js"><link rel="prefetch" href="/assets/js/14.9ff1a594.js"><link rel="prefetch" href="/assets/js/140.490ab53a.js"><link rel="prefetch" href="/assets/js/141.f828cb0d.js"><link rel="prefetch" href="/assets/js/142.a91c99db.js"><link rel="prefetch" href="/assets/js/143.c61ace89.js"><link rel="prefetch" href="/assets/js/144.6e0d6718.js"><link rel="prefetch" href="/assets/js/145.8696410b.js"><link rel="prefetch" href="/assets/js/146.78c11d9a.js"><link rel="prefetch" href="/assets/js/147.0997a658.js"><link rel="prefetch" href="/assets/js/148.95caa9a2.js"><link rel="prefetch" href="/assets/js/149.1edea028.js"><link rel="prefetch" href="/assets/js/15.1dc535fd.js"><link rel="prefetch" href="/assets/js/150.75246cad.js"><link rel="prefetch" href="/assets/js/151.b1a20d3d.js"><link rel="prefetch" href="/assets/js/152.35323c33.js"><link rel="prefetch" href="/assets/js/153.e8a07e92.js"><link rel="prefetch" href="/assets/js/154.9e340011.js"><link rel="prefetch" href="/assets/js/155.f479ad43.js"><link rel="prefetch" href="/assets/js/156.97192566.js"><link rel="prefetch" href="/assets/js/157.1c4ff3e8.js"><link rel="prefetch" href="/assets/js/158.d96ea397.js"><link rel="prefetch" href="/assets/js/159.0f55b599.js"><link rel="prefetch" href="/assets/js/16.8846169c.js"><link rel="prefetch" href="/assets/js/160.db7081e7.js"><link rel="prefetch" href="/assets/js/161.728959f2.js"><link rel="prefetch" href="/assets/js/162.3d9e425f.js"><link rel="prefetch" href="/assets/js/163.98406fd7.js"><link rel="prefetch" href="/assets/js/164.b4a7a898.js"><link rel="prefetch" href="/assets/js/165.41762074.js"><link rel="prefetch" href="/assets/js/166.cca0714a.js"><link rel="prefetch" href="/assets/js/167.20d13d31.js"><link rel="prefetch" href="/assets/js/168.65cd4b39.js"><link rel="prefetch" href="/assets/js/169.e774fc35.js"><link rel="prefetch" href="/assets/js/17.4240e60f.js"><link rel="prefetch" href="/assets/js/170.c680702a.js"><link rel="prefetch" href="/assets/js/171.aed76e50.js"><link rel="prefetch" href="/assets/js/172.f0126100.js"><link rel="prefetch" href="/assets/js/173.e13c21ae.js"><link rel="prefetch" href="/assets/js/174.95e6e362.js"><link rel="prefetch" href="/assets/js/175.9bc06660.js"><link rel="prefetch" href="/assets/js/176.2f30efee.js"><link rel="prefetch" href="/assets/js/177.9dda8b29.js"><link rel="prefetch" href="/assets/js/178.d60323ee.js"><link rel="prefetch" href="/assets/js/179.d3c55d73.js"><link rel="prefetch" href="/assets/js/18.20035b10.js"><link rel="prefetch" href="/assets/js/180.ee4dcc5c.js"><link rel="prefetch" href="/assets/js/181.f62c56c8.js"><link rel="prefetch" href="/assets/js/182.843f5e64.js"><link rel="prefetch" href="/assets/js/183.f763aa33.js"><link rel="prefetch" href="/assets/js/184.bf901285.js"><link rel="prefetch" href="/assets/js/185.f37d87b1.js"><link rel="prefetch" href="/assets/js/186.44f670ac.js"><link rel="prefetch" href="/assets/js/187.d85bcdb5.js"><link rel="prefetch" href="/assets/js/188.ea46513b.js"><link rel="prefetch" href="/assets/js/189.ebb0caf5.js"><link rel="prefetch" href="/assets/js/19.ddf4ad28.js"><link rel="prefetch" href="/assets/js/190.f6c6e508.js"><link rel="prefetch" href="/assets/js/191.ce7de326.js"><link rel="prefetch" href="/assets/js/192.5c4cf6ed.js"><link rel="prefetch" href="/assets/js/193.c9f03eb5.js"><link rel="prefetch" href="/assets/js/194.678693d2.js"><link rel="prefetch" href="/assets/js/195.63bdc5a6.js"><link rel="prefetch" href="/assets/js/196.50912f7b.js"><link rel="prefetch" href="/assets/js/197.5ddce07d.js"><link rel="prefetch" href="/assets/js/198.b370879e.js"><link rel="prefetch" href="/assets/js/199.06db7d09.js"><link rel="prefetch" href="/assets/js/20.e0c8bc0f.js"><link rel="prefetch" href="/assets/js/200.bed3f667.js"><link rel="prefetch" href="/assets/js/201.1c72ab8f.js"><link rel="prefetch" href="/assets/js/202.f124d4eb.js"><link rel="prefetch" href="/assets/js/203.0607eed3.js"><link rel="prefetch" href="/assets/js/204.5238cb27.js"><link rel="prefetch" href="/assets/js/205.2d7d10ed.js"><link rel="prefetch" href="/assets/js/206.9f7d327d.js"><link rel="prefetch" href="/assets/js/207.60e15733.js"><link rel="prefetch" href="/assets/js/208.6aad5fab.js"><link rel="prefetch" href="/assets/js/209.ec102045.js"><link rel="prefetch" href="/assets/js/21.8312f373.js"><link rel="prefetch" href="/assets/js/210.bdb6b7c2.js"><link rel="prefetch" href="/assets/js/211.4047d937.js"><link rel="prefetch" href="/assets/js/212.301d6d62.js"><link rel="prefetch" href="/assets/js/213.50739b59.js"><link rel="prefetch" href="/assets/js/214.e73a7105.js"><link rel="prefetch" href="/assets/js/215.a49b9947.js"><link rel="prefetch" href="/assets/js/216.4b324c1a.js"><link rel="prefetch" href="/assets/js/217.e144a18f.js"><link rel="prefetch" href="/assets/js/218.5f8ca4c2.js"><link rel="prefetch" href="/assets/js/219.e0554e51.js"><link rel="prefetch" href="/assets/js/22.d04d92c4.js"><link rel="prefetch" href="/assets/js/220.cf69c3aa.js"><link rel="prefetch" href="/assets/js/221.90c8f39d.js"><link rel="prefetch" href="/assets/js/222.a29f7ce4.js"><link rel="prefetch" href="/assets/js/223.10946c91.js"><link rel="prefetch" href="/assets/js/224.8b8a1423.js"><link rel="prefetch" href="/assets/js/225.6ae047dc.js"><link rel="prefetch" href="/assets/js/226.78b42e02.js"><link rel="prefetch" href="/assets/js/227.fc8c6347.js"><link rel="prefetch" href="/assets/js/228.66692a4b.js"><link rel="prefetch" href="/assets/js/229.356ca19b.js"><link rel="prefetch" href="/assets/js/23.c482eb11.js"><link rel="prefetch" href="/assets/js/230.f7b66079.js"><link rel="prefetch" href="/assets/js/231.6a772507.js"><link rel="prefetch" href="/assets/js/232.8df69fe9.js"><link rel="prefetch" href="/assets/js/233.52612384.js"><link rel="prefetch" href="/assets/js/234.52d782f6.js"><link rel="prefetch" href="/assets/js/235.9de060b1.js"><link rel="prefetch" href="/assets/js/236.ead9f5f0.js"><link rel="prefetch" href="/assets/js/237.8e9aa106.js"><link rel="prefetch" href="/assets/js/238.a6fd414e.js"><link rel="prefetch" href="/assets/js/239.11a8d58d.js"><link rel="prefetch" href="/assets/js/24.d26afd36.js"><link rel="prefetch" href="/assets/js/240.cbcaacef.js"><link rel="prefetch" href="/assets/js/241.07493fa0.js"><link rel="prefetch" href="/assets/js/242.f8eba775.js"><link rel="prefetch" href="/assets/js/243.0d69ee6a.js"><link rel="prefetch" href="/assets/js/244.b7f2acb3.js"><link rel="prefetch" href="/assets/js/245.db62d2b1.js"><link rel="prefetch" href="/assets/js/246.3f95f43d.js"><link rel="prefetch" href="/assets/js/247.550dcecb.js"><link rel="prefetch" href="/assets/js/248.ad5d9107.js"><link rel="prefetch" href="/assets/js/249.ba4a1c2e.js"><link rel="prefetch" href="/assets/js/25.5e69c47c.js"><link rel="prefetch" href="/assets/js/250.454b94bc.js"><link rel="prefetch" href="/assets/js/251.f705124c.js"><link rel="prefetch" href="/assets/js/252.376cd1f6.js"><link rel="prefetch" href="/assets/js/253.f22e0165.js"><link rel="prefetch" href="/assets/js/254.43f68d20.js"><link rel="prefetch" href="/assets/js/255.7d65096e.js"><link rel="prefetch" href="/assets/js/256.155db88e.js"><link rel="prefetch" href="/assets/js/257.ca476818.js"><link rel="prefetch" href="/assets/js/258.20b486ec.js"><link rel="prefetch" href="/assets/js/259.7d54b67b.js"><link rel="prefetch" href="/assets/js/26.29975dd9.js"><link rel="prefetch" href="/assets/js/260.8039879a.js"><link rel="prefetch" href="/assets/js/261.4462ad58.js"><link rel="prefetch" href="/assets/js/262.fd8ab3ac.js"><link rel="prefetch" href="/assets/js/263.7802cb43.js"><link rel="prefetch" href="/assets/js/264.a313cf79.js"><link rel="prefetch" href="/assets/js/265.9dbe4032.js"><link rel="prefetch" href="/assets/js/266.be1fc909.js"><link rel="prefetch" href="/assets/js/267.a336fc22.js"><link rel="prefetch" href="/assets/js/268.5acf1deb.js"><link rel="prefetch" href="/assets/js/269.a48f32bd.js"><link rel="prefetch" href="/assets/js/27.6f6c01db.js"><link rel="prefetch" href="/assets/js/270.31de0f7b.js"><link rel="prefetch" href="/assets/js/271.6e2d9cb7.js"><link rel="prefetch" href="/assets/js/272.4808cad4.js"><link rel="prefetch" href="/assets/js/273.ee065bcc.js"><link rel="prefetch" href="/assets/js/274.70a94c3a.js"><link rel="prefetch" href="/assets/js/275.d36aa6b9.js"><link rel="prefetch" href="/assets/js/276.ce7f1be1.js"><link rel="prefetch" href="/assets/js/277.38eb3494.js"><link rel="prefetch" href="/assets/js/278.51ec7c0b.js"><link rel="prefetch" href="/assets/js/279.ebceda59.js"><link rel="prefetch" href="/assets/js/28.e767bebb.js"><link rel="prefetch" href="/assets/js/280.72df8098.js"><link rel="prefetch" href="/assets/js/281.a53cbf13.js"><link rel="prefetch" href="/assets/js/282.f45ea8c4.js"><link rel="prefetch" href="/assets/js/283.5b0f353a.js"><link rel="prefetch" href="/assets/js/284.14b3dc6c.js"><link rel="prefetch" href="/assets/js/285.b70e9137.js"><link rel="prefetch" href="/assets/js/286.ba2445d2.js"><link rel="prefetch" href="/assets/js/287.bd0c107d.js"><link rel="prefetch" href="/assets/js/288.d5a2c989.js"><link rel="prefetch" href="/assets/js/289.b58ae803.js"><link rel="prefetch" href="/assets/js/29.93617baf.js"><link rel="prefetch" href="/assets/js/290.ecd09d31.js"><link rel="prefetch" href="/assets/js/291.d4b22e83.js"><link rel="prefetch" href="/assets/js/292.3aff1051.js"><link rel="prefetch" href="/assets/js/293.6d9b6f2e.js"><link rel="prefetch" href="/assets/js/294.2bd94374.js"><link rel="prefetch" href="/assets/js/295.96033774.js"><link rel="prefetch" href="/assets/js/296.a58435c2.js"><link rel="prefetch" href="/assets/js/297.9517b0d9.js"><link rel="prefetch" href="/assets/js/298.2ee61fb3.js"><link rel="prefetch" href="/assets/js/299.29712670.js"><link rel="prefetch" href="/assets/js/3.9f6e2e9b.js"><link rel="prefetch" href="/assets/js/30.b3063b77.js"><link rel="prefetch" href="/assets/js/300.7eb91a89.js"><link rel="prefetch" href="/assets/js/301.11149645.js"><link rel="prefetch" href="/assets/js/302.2da76e44.js"><link rel="prefetch" href="/assets/js/303.5a97825c.js"><link rel="prefetch" href="/assets/js/304.e7e9f99c.js"><link rel="prefetch" href="/assets/js/305.729eac97.js"><link rel="prefetch" href="/assets/js/306.52446818.js"><link rel="prefetch" href="/assets/js/307.1a54b756.js"><link rel="prefetch" href="/assets/js/308.33d8443c.js"><link rel="prefetch" href="/assets/js/309.0321f687.js"><link rel="prefetch" href="/assets/js/31.ca39c57a.js"><link rel="prefetch" href="/assets/js/310.1ec03007.js"><link rel="prefetch" href="/assets/js/311.77cafd1f.js"><link rel="prefetch" href="/assets/js/312.e7f6aa92.js"><link rel="prefetch" href="/assets/js/313.4fae326e.js"><link rel="prefetch" href="/assets/js/314.22babd10.js"><link rel="prefetch" href="/assets/js/315.5ff5f546.js"><link rel="prefetch" href="/assets/js/316.d6eb0b55.js"><link rel="prefetch" href="/assets/js/317.c4a4becf.js"><link rel="prefetch" href="/assets/js/318.4917ccd1.js"><link rel="prefetch" href="/assets/js/319.7cd4c7a0.js"><link rel="prefetch" href="/assets/js/32.8a11ea47.js"><link rel="prefetch" href="/assets/js/320.08da2e96.js"><link rel="prefetch" href="/assets/js/321.c5540b43.js"><link rel="prefetch" href="/assets/js/322.8e740136.js"><link rel="prefetch" href="/assets/js/323.e41da009.js"><link rel="prefetch" href="/assets/js/324.de0b55f5.js"><link rel="prefetch" href="/assets/js/325.aeaee9f2.js"><link rel="prefetch" href="/assets/js/326.fe9cc2c4.js"><link rel="prefetch" href="/assets/js/327.a3269dd0.js"><link rel="prefetch" href="/assets/js/328.52326fe4.js"><link rel="prefetch" href="/assets/js/329.5765e07d.js"><link rel="prefetch" href="/assets/js/33.fe31247b.js"><link rel="prefetch" href="/assets/js/330.076fdf59.js"><link rel="prefetch" href="/assets/js/331.a3910492.js"><link rel="prefetch" href="/assets/js/332.4d13179f.js"><link rel="prefetch" href="/assets/js/333.db605431.js"><link rel="prefetch" href="/assets/js/334.6870fbf8.js"><link rel="prefetch" href="/assets/js/335.71882ef0.js"><link rel="prefetch" href="/assets/js/336.29b8db0b.js"><link rel="prefetch" href="/assets/js/337.19e7677d.js"><link rel="prefetch" href="/assets/js/338.f57b293c.js"><link rel="prefetch" href="/assets/js/339.aeded597.js"><link rel="prefetch" href="/assets/js/34.5519b3a6.js"><link rel="prefetch" href="/assets/js/340.1ab52514.js"><link rel="prefetch" href="/assets/js/341.7a9b437d.js"><link rel="prefetch" href="/assets/js/342.cc7e6dd0.js"><link rel="prefetch" href="/assets/js/343.16c02c2f.js"><link rel="prefetch" href="/assets/js/344.644ae544.js"><link rel="prefetch" href="/assets/js/345.cb4fcfb5.js"><link rel="prefetch" href="/assets/js/346.7834b8ea.js"><link rel="prefetch" href="/assets/js/347.08f1647e.js"><link rel="prefetch" href="/assets/js/348.bacd8eff.js"><link rel="prefetch" href="/assets/js/349.416b554e.js"><link rel="prefetch" href="/assets/js/35.aa5fe427.js"><link rel="prefetch" href="/assets/js/350.b8fa939f.js"><link rel="prefetch" href="/assets/js/351.10599bab.js"><link rel="prefetch" href="/assets/js/352.ce5a06ac.js"><link rel="prefetch" href="/assets/js/353.4e916038.js"><link rel="prefetch" href="/assets/js/354.ed54e74f.js"><link rel="prefetch" href="/assets/js/355.be7e082e.js"><link rel="prefetch" href="/assets/js/356.0c574187.js"><link rel="prefetch" href="/assets/js/357.e65cd2a0.js"><link rel="prefetch" href="/assets/js/358.4e7bd228.js"><link rel="prefetch" href="/assets/js/359.fdb52927.js"><link rel="prefetch" href="/assets/js/36.1ae1780d.js"><link rel="prefetch" href="/assets/js/360.4b6e7453.js"><link rel="prefetch" href="/assets/js/361.de9efa49.js"><link rel="prefetch" href="/assets/js/362.b55b1906.js"><link rel="prefetch" href="/assets/js/363.527901e4.js"><link rel="prefetch" href="/assets/js/364.231218d3.js"><link rel="prefetch" href="/assets/js/365.1a344294.js"><link rel="prefetch" href="/assets/js/366.c8ea1c49.js"><link rel="prefetch" href="/assets/js/367.4c82e7e9.js"><link rel="prefetch" href="/assets/js/368.b3808528.js"><link rel="prefetch" href="/assets/js/369.9700ee29.js"><link rel="prefetch" href="/assets/js/37.19d7ef75.js"><link rel="prefetch" href="/assets/js/370.65605c2e.js"><link rel="prefetch" href="/assets/js/371.1223b27c.js"><link rel="prefetch" href="/assets/js/38.258cb0c1.js"><link rel="prefetch" href="/assets/js/39.0f268d7d.js"><link rel="prefetch" href="/assets/js/4.c4f52e09.js"><link rel="prefetch" href="/assets/js/40.3c3b852e.js"><link rel="prefetch" href="/assets/js/41.4097d760.js"><link rel="prefetch" href="/assets/js/42.591984a7.js"><link rel="prefetch" href="/assets/js/43.e1cbaa8b.js"><link rel="prefetch" href="/assets/js/44.650e2b5b.js"><link rel="prefetch" href="/assets/js/45.56567d27.js"><link rel="prefetch" href="/assets/js/46.3db58dc9.js"><link rel="prefetch" href="/assets/js/47.f6fabe74.js"><link rel="prefetch" href="/assets/js/48.dec3d0d2.js"><link rel="prefetch" href="/assets/js/5.e723c1a9.js"><link rel="prefetch" href="/assets/js/50.78409610.js"><link rel="prefetch" href="/assets/js/51.8c3db94b.js"><link rel="prefetch" href="/assets/js/52.ab9331d2.js"><link rel="prefetch" href="/assets/js/53.c87f3035.js"><link rel="prefetch" href="/assets/js/54.4ff4b7fd.js"><link rel="prefetch" href="/assets/js/55.d787c0fc.js"><link rel="prefetch" href="/assets/js/56.3744e41d.js"><link rel="prefetch" href="/assets/js/57.8f8e8c73.js"><link rel="prefetch" href="/assets/js/58.2a1927ed.js"><link rel="prefetch" href="/assets/js/59.24c87780.js"><link rel="prefetch" href="/assets/js/6.43debd78.js"><link rel="prefetch" href="/assets/js/60.72dc30a2.js"><link rel="prefetch" href="/assets/js/61.76ba61eb.js"><link rel="prefetch" href="/assets/js/62.9e0cced6.js"><link rel="prefetch" href="/assets/js/63.63ad730b.js"><link rel="prefetch" href="/assets/js/64.07a7e3a3.js"><link rel="prefetch" href="/assets/js/65.3c172f80.js"><link rel="prefetch" href="/assets/js/66.c0275e13.js"><link rel="prefetch" href="/assets/js/67.a87a6f6e.js"><link rel="prefetch" href="/assets/js/68.69d976e5.js"><link rel="prefetch" href="/assets/js/69.bfdbe5e9.js"><link rel="prefetch" href="/assets/js/7.23b88edf.js"><link rel="prefetch" href="/assets/js/70.49f5f451.js"><link rel="prefetch" href="/assets/js/71.415f2315.js"><link rel="prefetch" href="/assets/js/72.8608e946.js"><link rel="prefetch" href="/assets/js/73.dda863c5.js"><link rel="prefetch" href="/assets/js/74.0fccbeb8.js"><link rel="prefetch" href="/assets/js/75.7353b526.js"><link rel="prefetch" href="/assets/js/76.0770d54e.js"><link rel="prefetch" href="/assets/js/77.5d128881.js"><link rel="prefetch" href="/assets/js/78.09c3bef7.js"><link rel="prefetch" href="/assets/js/79.99dacc09.js"><link rel="prefetch" href="/assets/js/8.9344fafb.js"><link rel="prefetch" href="/assets/js/80.d7dbccbf.js"><link rel="prefetch" href="/assets/js/81.fc4d9a9e.js"><link rel="prefetch" href="/assets/js/82.2bf1c68d.js"><link rel="prefetch" href="/assets/js/83.af673b81.js"><link rel="prefetch" href="/assets/js/84.8a6fa1bd.js"><link rel="prefetch" href="/assets/js/85.e17db901.js"><link rel="prefetch" href="/assets/js/86.23dc25fe.js"><link rel="prefetch" href="/assets/js/87.b2cc7e3f.js"><link rel="prefetch" href="/assets/js/88.05b83c84.js"><link rel="prefetch" href="/assets/js/89.3bfd9b3f.js"><link rel="prefetch" href="/assets/js/9.8c1ccb14.js"><link rel="prefetch" href="/assets/js/90.8171bd61.js"><link rel="prefetch" href="/assets/js/91.800cce9f.js"><link rel="prefetch" href="/assets/js/92.8ff96830.js"><link rel="prefetch" href="/assets/js/93.ebbadaf8.js"><link rel="prefetch" href="/assets/js/94.98d7f109.js"><link rel="prefetch" href="/assets/js/95.d3629849.js"><link rel="prefetch" href="/assets/js/96.cc729091.js"><link rel="prefetch" href="/assets/js/97.9a25e809.js"><link rel="prefetch" href="/assets/js/98.cea1a674.js"><link rel="prefetch" href="/assets/js/99.4f973974.js">
    <link rel="stylesheet" href="/assets/css/0.styles.76271d17.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">coder</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/01_ProgrammingBasic/link.html" class="nav-link">
  编程基础
</a></li><li class="dropdown-item"><!----> <a href="/java/02_DevelopmentTools/link.html" class="nav-link">
  开发工具
</a></li><li class="dropdown-item"><!----> <a href="/java/03_ApplicationFramework/link.html" class="nav-link">
  应用框架
</a></li><li class="dropdown-item"><!----> <a href="/java/04_OperationAndMaintenance/" class="nav-link">
  运维
</a></li><li class="dropdown-item"><!----> <a href="/java/05_SourceCode/" class="nav-link">
  源码
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/web/01_vue/使用webpack打包一个简单的前端程序.html" class="nav-link">
  vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具箱" class="dropdown-title"><span class="title">工具箱</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具箱" class="mobile-dropdown-title"><span class="title">工具箱</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tools/essay/04_SpringBoot中处理跨域的几种方式.html" class="nav-link">
  随笔
</a></li><li class="dropdown-item"><!----> <a href="/tools/installSoftware/01_jdk_linux.html" class="nav-link">
  软件安装
</a></li><li class="dropdown-item"><!----> <a href="/tools/bugRepository/03_MySQL主从复制Bug.html" class="nav-link">
  bug库
</a></li><li class="dropdown-item"><!----> <a href="/tools/other/07_打包插件maven-assembly-plugin.html" class="nav-link">
  其他
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/interview/" class="nav-link">
  面试
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/01_ProgrammingBasic/link.html" class="nav-link">
  编程基础
</a></li><li class="dropdown-item"><!----> <a href="/java/02_DevelopmentTools/link.html" class="nav-link">
  开发工具
</a></li><li class="dropdown-item"><!----> <a href="/java/03_ApplicationFramework/link.html" class="nav-link">
  应用框架
</a></li><li class="dropdown-item"><!----> <a href="/java/04_OperationAndMaintenance/" class="nav-link">
  运维
</a></li><li class="dropdown-item"><!----> <a href="/java/05_SourceCode/" class="nav-link">
  源码
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/web/01_vue/使用webpack打包一个简单的前端程序.html" class="nav-link">
  vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具箱" class="dropdown-title"><span class="title">工具箱</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具箱" class="mobile-dropdown-title"><span class="title">工具箱</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/tools/essay/04_SpringBoot中处理跨域的几种方式.html" class="nav-link">
  随笔
</a></li><li class="dropdown-item"><!----> <a href="/tools/installSoftware/01_jdk_linux.html" class="nav-link">
  软件安装
</a></li><li class="dropdown-item"><!----> <a href="/tools/bugRepository/03_MySQL主从复制Bug.html" class="nav-link">
  bug库
</a></li><li class="dropdown-item"><!----> <a href="/tools/other/07_打包插件maven-assembly-plugin.html" class="nav-link">
  其他
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JVM</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/01_jvm.html" class="sidebar-link">JVM</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/01_JVM与Java体系结构.html" class="sidebar-link">JVM与Java体系结构</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/02_类加载子系统.html" class="sidebar-link">类加载子系统</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/03_运行时数据区概述及线程.html" class="sidebar-link">运行时数据区概述及线程</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/04_程序计数器.html" class="sidebar-link">程序计数器</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/05_虚拟机栈.html" class="sidebar-link">虚拟机栈</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/06_本地方法接口.html" class="sidebar-link">本地方法接口</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/07_本地方法栈.html" class="sidebar-link">本地方法栈</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/08_堆.html" class="sidebar-link">堆</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/09_方法区.html" class="sidebar-link">方法区</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/10_对象的实例化内存布局与访问定位.html" class="sidebar-link">对象的实例化内存布局与访问定位</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/11_直接内存.html" class="sidebar-link">直接内存</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/12_执行引擎.html" class="sidebar-link">执行引擎</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/13_StringTable.html" class="sidebar-link">StringTable</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/14_垃圾回收概述.html" class="sidebar-link">垃圾回收概述</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/15_垃圾回收相关算法.html" class="sidebar-link">垃圾回收相关算法</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/16_垃圾回收相关概念.html" class="sidebar-link">垃圾回收相关概念</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/17_垃圾回收器.html" class="sidebar-link">垃圾回收器</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/18_Class文件结构.html" class="sidebar-link">Class文件结构</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/19_字节码指令集与解析举例.html" class="sidebar-link">字节码指令集与解析举例</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/20_类的加载过程.html" class="sidebar-link">类的加载过程</a></li><li><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/21_类的加载器.html" class="active sidebar-link">类的加载器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/21_类的加载器.html#一、概述" class="sidebar-link">一、概述</a></li><li class="sidebar-sub-header"><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/21_类的加载器.html#二、类加载器分类" class="sidebar-link">二、类加载器分类</a></li><li class="sidebar-sub-header"><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/21_类的加载器.html#三、测试不同的类加载器" class="sidebar-link">三、测试不同的类加载器</a></li><li class="sidebar-sub-header"><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/21_类的加载器.html#四、classloader源码分析" class="sidebar-link">四、ClassLoader源码分析</a></li><li class="sidebar-sub-header"><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/21_类的加载器.html#五、双亲委派模型" class="sidebar-link">五、双亲委派模型</a></li><li class="sidebar-sub-header"><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/21_类的加载器.html#六、沙箱安全机制" class="sidebar-link">六、沙箱安全机制</a></li><li class="sidebar-sub-header"><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/21_类的加载器.html#七、自定义类加载器" class="sidebar-link">七、自定义类加载器</a></li><li class="sidebar-sub-header"><a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/21_类的加载器.html#八、java9新特性" class="sidebar-link">八、Java9新特性</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>多线程&amp;高并发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JDK_Tools</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="类的加载器"><a href="#类的加载器" class="header-anchor">#</a> 类的加载器</h1> <h2 id="一、概述"><a href="#一、概述" class="header-anchor">#</a> 一、概述</h2> <h3 id="_1-1-面试题"><a href="#_1-1-面试题" class="header-anchor">#</a> 1.1 面试题</h3> <ol><li>深入分析<code>ClassLoader</code>、双亲委派机制</li> <li>类加载器的双亲委派模型是什么，优点有哪些</li> <li>双亲委派机制及使用原因</li> <li>都有哪些类加载器，分别加载哪些文件</li> <li><code>Class</code>的 <code>forName(&quot;java.lang.String&quot;)</code> 和 <code>Class</code>的 <code>getClassLoader()</code> 的 <code>loadClass(&quot;java.lang.String&quot;)</code>有什么区别？</li> <li>双亲委派机制可以打破吗？为什么？</li></ol> <h3 id="_1-2-类加载的分类"><a href="#_1-2-类加载的分类" class="header-anchor">#</a> 1.2 类加载的分类</h3> <p>类的加载分类：<strong>显式加载</strong> vs <strong>隐式加载</strong></p> <p><code>Class</code> 文件的显式加载与隐式加载的方式是指 <code>JVM</code> 加载 <code>Class</code> 文件到内存的方式</p> <ul><li>显式加载指的是在代码中通过调用 <code>ClassLoader</code> 加载 <code>Class</code> 对象，如直接使用 <code>Class.forName(name)</code> 或 <code>this.getClass().getClassLoader().loadClass()</code> 加载 <code>Class</code>对象</li> <li>隐式加载则是不直接在代码中调用 <code>ClassLoader</code> 的方法加载 <code>Class</code> 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 <code>Class</code> 文件时，该类的 <code>Class</code> 文件中引用了另外一个类的对象，此时额外引用的类将通过 <code>JVM</code> 自动加载到内存中</li></ul> <p>在日常开发中以上两种方式一般会混合使用</p> <h3 id="_1-3-类加载器的必要性"><a href="#_1-3-类加载器的必要性" class="header-anchor">#</a> 1.3 类加载器的必要性</h3> <p>一般情况下，<code>Java</code> 开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p> <ul><li>避免在开发中遇到 <code>java.lang.ClassNotFoundException</code> 异常或 <code>java.lang.NoClassDeFoundError</code> 异常时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li> <li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了</li> <li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑</li></ul> <h3 id="_1-4-命名空间"><a href="#_1-4-命名空间" class="header-anchor">#</a> 1.4 命名空间</h3> <ol><li><p>何为类的唯一性？
对于任意一个类，都需要由<strong>加载它的类加载器和这个类本身</strong>一同确认其在 <code>Java</code>虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个 <code>Class</code>文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等</p></li> <li><p>命名空间</p> <ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器以及所有的父加载器所加载的类组成</li> <li>在同一命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类</li> <li>在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类</li></ul></li></ol> <p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本</p> <h3 id="_1-5-类加载机制的基本特征"><a href="#_1-5-类加载机制的基本特征" class="header-anchor">#</a> 1.5 类加载机制的基本特征</h3> <p>通常类加载机制有三个基本特征：</p> <ol><li><strong>双亲委派模型</strong>。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 <code>JDK</code>内部的 <code>ServiceProvider/ServiceLoader</code>机制，用户可以在标准 <code>API</code> 框架上，提供自己的实现，<code>JDK</code> 也需要提供些默认的参考实现。例如，<code>Java</code> 中 <code>JNDI</code>、<code>JDBC</code>、文件系统、<code>Cipher</code> 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器</li> <li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑</li> <li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器&quot;邻居&quot;间，同一类型仍然可以被加载多次，因为相互并不可见</li></ol> <h2 id="二、类加载器分类"><a href="#二、类加载器分类" class="header-anchor">#</a> 二、类加载器分类</h2> <p>JVM 支持两种类型的类加载器，分别为<strong>引导类加载器(Bootstrap ClassLoader)<strong>和</strong>自定义类加载器(User-Defined ClassLoader)</strong></p> <p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p> <p><a data-fancybox="" title="image-20210330235747266" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/893dbf79504646cb8c4d6a0bab50e8b7.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/893dbf79504646cb8c4d6a0bab50e8b7.png" alt="image-20210330235747266"></a></p> <ul><li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的&quot;父类&quot;加载器</li> <li>不同类加载器看似是继承(Inheritance)关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用</li></ul> <p>“父类加载器”并非下层加载器extends上层加载器，而是包含了上层加载器的引用</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>
    <span class="token class-name">ClassLoader</span> parent<span class="token punctuation">;</span> <span class="token comment">//父类加载器</span>

    <span class="token keyword">public</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ParentClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">ParentClassLoader</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ChildClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">ChildClassLoader</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//parent = new ParentClassLoader();</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-1-引导类加载器"><a href="#_2-1-引导类加载器" class="header-anchor">#</a> 2.1 引导类加载器</h3> <p>启动类加载器(引导类加载器，<code>Bootstrap ClassLoader</code>)</p> <ul><li>这个类加载使用 <code>C/C++</code> 语言实现的，嵌套在 <code>JVM</code> 内部</li> <li>它用来加载 <code>Java</code> 的核心库(<code>JAVA_HOME/jre/lib/rt.jar</code> 或 <code>sun.boot.class.path</code> 路径下的内容)。用于提供 <code>JVM</code> 自身需要的类</li> <li>并不继承自 <code>java.lang.ClassLoader</code>，没有父加载器</li> <li>出于安全考虑，<code>Bootstrap</code> 启动类加载器加载包名为 <code>java、javax、sun</code> 等开头的类</li> <li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li></ul> <p><a data-fancybox="" title="image-20210331000338383" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/13d2d401d564424d8f81d7fd71bfe577.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/13d2d401d564424d8f81d7fd71bfe577.png" alt="image-20210331000338383"></a></p> <p><a data-fancybox="" title="image-20210331000349136" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/c93dc27eaa7142ab8b42df95b99c5d05.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/c93dc27eaa7142ab8b42df95b99c5d05.png" alt="image-20210331000349136"></a></p> <p>使用 <code>-XX:+TraceClassLoading</code>参数</p> <p>启动类加载器使用 <code>C++</code> 编写的？Yes！
<code>C/C++</code>：指针函数 &amp; 函数指针、C++ 支持多继承、更加高效
<code>Java</code> ：由 C++ 演变而来，(C++)-- 版，单继承</p> <h3 id="_2-2-扩展类加载器"><a href="#_2-2-扩展类加载器" class="header-anchor">#</a> 2.2 扩展类加载器</h3> <ul><li><p>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现</p></li> <li><p>继承于 ClassLoader 类</p></li> <li><p>父类加载器为启动类加载器</p></li> <li><p>从 <code>java.ext.dirs</code> 系统属性所指定的目录中加载类库，或从 <code>JDK</code> 的安装目录的 <code>jre/lib/ext</code> 子目录下加载类库。如果用户创建的 <code>JAR</code> 放在此目录下，也会自动由扩展类加载器加载</p> <p><a data-fancybox="" title="image-20210331001047371" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/17b581f44a7c42848290537063ba80c6.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/17b581f44a7c42848290537063ba80c6.png" alt="image-20210331001047371"></a></p></li></ul> <h3 id="_2-3-系统类加载器"><a href="#_2-3-系统类加载器" class="header-anchor">#</a> 2.3 系统类加载器</h3> <p>系统类加载器也称为应用程序类加载器</p> <ul><li><code>Java</code> 语言编写，由 <code>sun.misc.Launcher$AppClassLoader</code> 实现</li> <li>继承于 <code>ClassLoader</code> 类</li> <li>父类加载器为扩展类加载器</li> <li>它负责加载环境变量 <code>classpath</code> 或系统属性 <code>java.class.path</code> 指定路径下的类库</li> <li>应用程序中的类加载器默认是系统类加载器</li> <li>它是用户自定义类加载器的默认父加载器</li> <li>通过 <code>ClassLoader</code> 的 <code>getSystemClassLoader()</code> 方法可以获取到该类加载器</li></ul> <h3 id="_2-4-用户自定义类加载器"><a href="#_2-4-用户自定义类加载器" class="header-anchor">#</a> 2.4 用户自定义类加载器</h3> <ul><li>在 Java 的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式</li> <li>体现 Java 语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的 JAR 包，也可以是网络上的远程资源</li> <li>通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例不胜枚举。例如，著名的 OSGI 组件框架，再如 Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无需重新打包发布应用程序就能实现</li> <li>同时，自定义加载器能够实现应用隔离，例如 Tomcat、Spring 等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比 C/C++ 程序要好太多，想不修改 C/C++ 程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡所有美好的设想</li> <li>自定义类加载器通常需要继承于 ClassLoader</li></ul> <h2 id="三、测试不同的类加载器"><a href="#三、测试不同的类加载器" class="header-anchor">#</a> 三、测试不同的类加载器</h2> <p>每个 <code>Class</code> 对象都会包含一个定义它的 <code>ClassLoader</code> 的一个引用</p> <p>获取 <code>ClassLoader</code> 的途径</p> <p><a data-fancybox="" title="image-20210331003000926" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/17bd9794c84e4685894c356f5ba64a88.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/17bd9794c84e4685894c356f5ba64a88.png" alt="image-20210331003000926"></a></p> <p>说明：
站在程序的角度看，引导类加载器与另外两种类加载器(系统类加载器和扩展类加载器)并不是同一个层次意义上的加载器，引导类加载器是使用 C++ 语言编写而成的，而另外两种类加载器则是使用 Java 语言编写的。由于引导类加载器压根儿就不是一个 Java 类，因此在 Java 程序中只能打印出空值</p> <p><strong>数组类的 Class 对象，不是由类加载器去创建的，而是在 Java 运行期 JVM 根据需要自动创建的。</strong> 对于数组类的类加载器来说，是通过 <code>Class.geetClassLoader()</code> 返回的，与数组当中元素类型的类加载器是一样的：<strong>如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strArr<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//运行结果：null</span>
 
<span class="token class-name">ClassLoaderTest</span><span class="token punctuation">[</span><span class="token punctuation">]</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoaderTest</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//运行结果：sun.misc.Launcher$AppClassLoader@18b4aac2</span>
 
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>inst<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//运行结果：null</span>
</code></pre></div><h2 id="四、classloader源码分析"><a href="#四、classloader源码分析" class="header-anchor">#</a> 四、ClassLoader源码分析</h2> <p><code>ClassLoader</code>与现有类加载的关系：</p> <p><a data-fancybox="" title="image-20210331145230981" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/eb7b950a44674f2b848405b720e11437.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-31/eb7b950a44674f2b848405b720e11437.png" alt="image-20210331145230981"></a></p> <p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。<code>Java</code>提供了抽象类 <code>java.lang.ClassLoader</code>，所有用户自定义的类加载器都应该继承 <code>ClassLoader</code>类</p> <h3 id="_4-1-classloader-的主要方法"><a href="#_4-1-classloader-的主要方法" class="header-anchor">#</a> 4.1 ClassLoader 的主要方法</h3> <ol><li><p>获取该类加载器的父类加载器</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> <span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>根据名称加载类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
</code></pre></div><p>加载名称为 <code>name</code> 的类，返回的结果为 <code>Class</code> 类对象，如果找不到名称为 <code>name</code> 的类，则抛出异常 <code>ClassNotFoundException</code>，该方法的具体实现，就是双亲委派模型</p></li> <li><p>根据名称查找类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
</code></pre></div><p>查找名为 <code>name</code> 的类，返回结果是 <code>Class</code> 类对象</p> <p>在<code>JDK1.2</code>之前，在自定义类加载时，总会去继承<code>ClassLoader</code>类并重写<code>loadClass</code>方法，从而实现自定义的类加载类。但是在<code>JDK1.2</code>之后已不再建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中，从前面的分析可知， <code>findClass()</code>方法是在<code>loadClass()</code>方法中被调用的，当<code>loadClass()</code>方法中父加载器加载失败后，则会调用自己的<code>findClass()</code>方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是<code>ClassLoader</code>类中并没有实现<code>findClass()</code>方法的具体代码逻辑，取而代之的是抛出<code>ClassNotFoundException</code>异常，同时应该知道的是<code>findClass</code>方法通常是和<code>defineClass</code>方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖<code>ClassLoader</code>的<code>findClass()</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的<code>Class</code>对象。</p></li> <li><p>将字节数组转换为<code>Class</code>对象</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
</code></pre></div><p>根据给定的字节数组b转换为<code>Class</code>的实例，<code>off</code>和<code>len</code>参数表示实际<code>Class</code>信息在<code>byte</code>数组中的位置和长度，其中<code>byte</code>数组b是<code>ClassLoader</code>从外部获取的。这是受保护的方法，只有在自定义<code>ClassLoader</code>子类中可以使用。</p> <p><code>defineClass()</code>方法是用来将<code>byte</code>字节流解析成<code>JVM</code>能够识别的<code>Class</code>对象(<code>ClassLoader</code>中已实现该方法逻辑)，通过这个方法不仅能够通过<code>class</code>文件实例化<code>class</code>对象，也可以通过其他方式实例化<code>class</code>对象，如通过网络接收一个类的字节码，然后转换为<code>byte</code>字节流创建对应的<code>Class</code>对象。
<code>defineClass()</code>方法通常与<code>findClass()</code>方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖<code>ClassLoader</code>的<code>findClass()</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的<code>Class</code>对象</p></li> <li><p>链接指定的一个<code>Java</code>类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">resolveClass</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span>
</code></pre></div><p>链接指定的一个<code>Java</code>类。使用该方法可以使用类的<code>Class</code>对象创建完成的同时也被解析(即加载的同时也进行解析)。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p></li> <li><p>根据名称查找已经被加载的类</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>
</code></pre></div><p>查找名称为<code>name</code>的已经被加载过的类，返回结果为<code>java.lang.Class</code>类的实例。这个方法是<code>final</code>方法，无法被修改</p></li> <li><p>ClassLoader的双亲</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> parent
</code></pre></div><p>它也是一个<code>ClassLoader</code>的实例，这个字段所表示的<code>ClassLoader</code>也称为这个<code>ClassLoader</code>的双亲。在类加载的过程中,<code>ClassLoader</code>可能会将某些请求交予自己的双亲处理。</p></li> <li><p>剖析loadClass方法</p> <p>测试代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">&quot;com.it.User&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>涉及到对如下方法的调用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//resolve:true-加载class的同时进行解析操作。</span>
<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
    <span class="token comment">//同步操作，保证只能加载一次。</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment">// First, check if the class has already been loaded</span>
       <span class="token comment">//首先，在缓存中判断是否已经加载同名的类</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">//获取当前类加载器的父类加载器。</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">//如果存在父类加载器，则调用父类加载器进行类的加载（递归）</span>
                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">//parent为null:父类加载器是引导类加教器</span>
                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// ClassNotFoundException thrown if class not found</span>
                <span class="token comment">// from the non-null parent class loader</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//当前类的加载器的父类加载器未加载此类or此类的加载器未加载此类</span>
                <span class="token comment">// If still not found, then invoke findClass in order</span>
                <span class="token comment">// to find the class.</span>
                <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//调用当前ClassLoader的findClass()</span>
                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// this is the defining class loader; record the stats</span>
                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token class-name">PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>
                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token class-name">PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token class-name">PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//是否进行解析操作</span>
            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 

</code></pre></div></li></ol> <h3 id="_4-2-secureclassloader与urlclassloader"><a href="#_4-2-secureclassloader与urlclassloader" class="header-anchor">#</a> 4.2 SecureClassLoader与URLClassLoader</h3> <p><code>SecureClassLoader</code>扩展了<code>ClassLoader</code>，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对<code>class</code>源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类<code>URLClassLoader</code>有所关联。</p> <p>前面说过，<code>ClassLoader</code>是一个抽象类，很多方法是空的没有实现，比如 <code>findClass</code>()、<code>findResource()</code>等。而<code>URLClassLoader</code>这个实现类为这些方法提供了具体的实现。并新增了<code>URLClassPath</code>类协助取得<code>Class</code>字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承<code>URLClassLoader</code>类，这样就可以避免自己去编写<code>findClass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p> <p><a data-fancybox="" title="image-20210401092059190" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/7e904d3e5e05444e87bf01002d15cbfe.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/7e904d3e5e05444e87bf01002d15cbfe.png" alt="image-20210401092059190"></a></p> <h3 id="_4-3-extclassloader与appclassloader"><a href="#_4-3-extclassloader与appclassloader" class="header-anchor">#</a> 4.3 ExtClassLoader与AppClassLoader</h3> <p>拓展类加载器ExtClassLoader和系统类加载AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。
sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下:</p> <p><a data-fancybox="" title="image-20210401092446708" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/1af6cc3a8e2f4ae48f1e44ecaa004a74.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/1af6cc3a8e2f4ae48f1e44ecaa004a74.png" alt="image-20210401092446708"></a></p> <h3 id="_4-4-class-forname与classloader-loadclass"><a href="#_4-4-class-forname与classloader-loadclass" class="header-anchor">#</a> 4.4 Class.forName与ClassLoader.loadClass()</h3> <ul><li><p><code>Class.forName()</code>: 是一个静态方法,最常用的是<code>Class.forName(String className)</code>;根据传入的类的全限定名返回一个Class对象。<strong>该方法在将Class文件加载到内存的同时,会执行类的初始化。</strong></p> <p>如:<code>Class.forName( &quot;com.it.Helloworld&quot;)</code> ;</p></li> <li><p><code>ClassLoader.loadClass()</code>: 这是一个实例方法,需要一个<code>ClassLoader</code>对象来调用该方法。**该方法将<code>class</code>文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化。**该方法因为需要得到个<code>ClassLoader</code>对象,所以可以根据需要指定使用哪个类加载器.如: <code>ClassLoader cl=......;</code></p> <p><code>cl.loadClass (&quot;com.atguigu.java.Helloworld&quot; );</code></p></li></ul> <h2 id="五、双亲委派模型"><a href="#五、双亲委派模型" class="header-anchor">#</a> 五、双亲委派模型</h2> <h3 id="_5-1-定义与本质"><a href="#_5-1-定义与本质" class="header-anchor">#</a> 5.1 定义与本质</h3> <p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证java平台的安全。</p> <p>**定义：**如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p> <p>**本质：**规定了类加载的顺序是，引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p> <p><a data-fancybox="" title="image-20210401094754200" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/9628cd0f485440d4832121dd08f21883.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/9628cd0f485440d4832121dd08f21883.png" alt="image-20210401094754200"></a></p> <p><a data-fancybox="" title="image-20210401095449336" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/b8f49fab72f34abb8d58762a1ecda111.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/b8f49fab72f34abb8d58762a1ecda111.png" alt="image-20210401095449336"></a></p> <h3 id="_5-2-优势与劣势"><a href="#_5-2-优势与劣势" class="header-anchor">#</a> 5.2 优势与劣势</h3> <ol><li><p>双亲委派机制优势
避免类的重复加载，确保一个类的全局唯一性
Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
保护程序安全，防止核心API被随意篡改</p></li> <li><p>代码支持
双亲委派机制在<code>java.lang.ClassLoader.loadClass(String,boolean)</code>接口中体现。该接口的逻辑如下:</p> <ol><li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li> <li>判断当前加载器的父加载器是否为空，如果不为空，则调用<code>parent.loadClass(name，false)</code>接口进行加载。</li> <li>反之，如果当前加载器的父类加载器为空，则调用<code>findBootstrapClassOrNull(name)</code>接口，让引导类加载器进加载。</li> <li>如果通过以上3条路径都没能成功加载，则调用<code>findClass(name)</code>方法进行加载。该接口最终会调用<code>java.lang.ClassLoader</code>接口的<code>defineClass</code>系列的native接口加载目标<code>Java</code>类。
双亲委派的模型就隐藏在这第2和第3步中。</li></ol></li> <li><p>举例
假设当前加载的是<code>java.lang.Object</code>这个类，很显然，该类属于<code>JDK</code>中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当<code>JVM</code>准备加载<code>java.lang.Object</code>时，<code>JVM</code>默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null,因此系统调用<code>findClass(String)</code>，最终通过引导类加载器进行加载。</p></li> <li><p>思考
如果在自定义的类加载器中重写<code>java.lang.ClassLoader.loadClass(String)</code>或<code>java.lang.ClassLoader.loadClass(String, boolean)</code>方法,抹去其中的双亲委派机制,仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢?
这也不行!因为<code>JDK</code>还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器还是扩展类加载器，最终都必须调用<code>java.lang.classLoader.defineClass(String,byte[], int, int, ProtectionDomain)</code>方法，而该方法会执行<code>preDefineClass()</code>接口，该接口中提供了对<code>JDK</code>核心类库的保护。</p></li> <li><p>双亲委托模式的弊端
检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个<code>ClassLoader</code>的职责非常明确，但是同时会带来一个问题，即顶层的<code>ClassLoader</code>无法访问底层的<code>ClassLoader</code>所加载的类。</p></li></ol> <p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p> <ol start="6"><li>结论
由于<code>Java</code>虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而己。
比如在<code>Tomcat</code>中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</li></ol> <h3 id="_5-3-破坏双亲委派机制"><a href="#_5-3-破坏双亲委派机制" class="header-anchor">#</a> 5.3 破坏双亲委派机制</h3> <p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p> <p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p> <ol><li><p>第一次破坏双亲委派机制</p> <p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前--即<code>JDK1.2</code>面世以前的“远古”时代。
由于双亲委派模型在<code>JDK 1.2</code>之后才被引入，但是类加载器的概念和抽象类<code>java.lang.ClassLoader</code>则在<code>Java</code>的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，<code>Java</code>设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免<code>loadClass()</code>被子类覆盖的可能性，只能在<code>JDK1.2</code>之后的<code>java.lang.ClassLoader</code>中添加一个新的<code>protected</code>方法<code>findClass()</code>，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在<code>loadClass()</code>中编写代码。上节我们已经分析过<code>loadClass()</code>方法，双亲委派的具体逻辑就实现在这里面，按照<code>loadClass()</code>方法的逻辑，如果父类加载失败，会自动调用自己的<code>findClass()</code>方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p></li> <li><p>第二次破坏双亲委派机制</p> <p>线程上下文类加载器</p> <p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题〈越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的<code>API</code>存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码,那该怎么办呢?</p> <p>这并非是不可能出现的事情，一个典型的例子便是<code>JNDI</code>服务，<code>JNDI</code>现在已经是<code>Java</code>的标准服务，它的代码由启动类加载器来完成加载（在<code>JDK 1.3</code>时加入到<code>rt.jar</code>的)，肯定属于<code>Java</code>中很基础的类型了。但<code>JNDI</code>存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的<code>ClassPath</code>下的<code>NDI</code>服务提供者接口（<code>Service Provider Interface，SPI</code>）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办?(<code>SPI</code>: 在<code>Java</code>平台中，通常把核心类<code>rt.jar</code>中提供外部服务、可由应用层自行实现的接口称为<code>SPI</code>)</p> <p>为了解决这个困境，<code>Java</code>的设计团队只好引入了一个不太优雅的设计:线程上下文类加载器（<code>Thread ContextClassLoader</code>)。这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是<strong>应用程序类加载器</strong>。</p> <p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。<code>JNDI</code>服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。<code>Java</code>中涉及<code>SPI</code>的加载基本上都采用这种方式来完成，例如<code>NDI、JDBC、JCE、JAXB</code>和<code>BT</code>等。不过，当<code>SPI</code>的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在<code>JDK 6</code>时，<code>JDK</code>提供了<code>java.util.ServiceLoader</code>类，以<code>META-INF/services</code>中的配置信息，辅以责任链模式，这才算是给<code>SPI</code>的加载提供了一种相对合理的解决方案。</p> <p><a data-fancybox="" title="image-20210401101844601" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/31d1af3f22d54e158d54912dea88d72d.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/31d1af3f22d54e158d54912dea88d72d.png" alt="image-20210401101844601"></a></p> <p><strong>默认上下文加载器就是应用类加载器</strong>，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p></li> <li><p>第三次破坏双亲委派机制</p> <p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:代码热替换<code>（Hot Swap)</code>、模块热部署（<code>Hot Deployment</code>）等
<code>IBM</code>公司主导的<code>JSR-291</code>(即<code>OSGi R4.2</code>）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（<code>OSGi</code>中称为<code>Bundle</code>)都有一个自己的类加载器，当需要更换一个<code>Bundle</code>时，就把<code>Bundle</code>连同类加载器一起换掉以实现代码的热替换。在<code>OSGi</code>环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p> <p>当收到类加载请求时，<code>OSGi</code>将按照下面的顺序进行类搜索:（不细讲）</p> <ol><li>将以<code>java.*</code>开头的类，委派给父类加载器加载。</li> <li>否则，将委派列表名单内的类，委派给父类加载器加载。</li> <li>否则，将<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li> <li>否则，查找当前<code>Bundle</code>的<code>ClassPath</code>，使用自己的类加载器加载。</li> <li>否则，查找类是否在自己的<code>Fragment Bundle</code>中，如果在，则委派给<code>Fragment Bundle</code>的类加载器加载。</li> <li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li> <li>否则，类查找失败。
说明:只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</li></ol> <p>小结:
这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p> <p>正如<code>OSGi</code>中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<code>OSGi</code>中对类加载器的运用是值得学习的，完全弄懂了<code>OSGi</code>的实现，就算是掌握了类加载器的精粹。</p></li></ol> <h3 id="_5-4-热替换的实现"><a href="#_5-4-热替换的实现" class="header-anchor">#</a> 5.4 热替换的实现</h3> <p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如: PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p> <p>但对<code>Java</code>来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重新定义这个类。因此，在<code>Java</code>中实现这一功能的一个可行的方法就是灵活运用<code>ClassLoader</code>。</p> <p>注意: 由不同<code>ClassLoader</code>加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的<code>ClassLoader</code>加载同个类，在虚拟机内部，会认为这2个类是完全不同的。</p> <p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示:</p> <p><a data-fancybox="" title="image-20210401103332009" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/a471dca7f25248f183d9f87ba413cc11.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/a471dca7f25248f183d9f87ba413cc11.png" alt="image-20210401103332009"></a></p> <h2 id="六、沙箱安全机制"><a href="#六、沙箱安全机制" class="header-anchor">#</a> 六、沙箱安全机制</h2> <h3 id="_6-1-jdk1-0"><a href="#_6-1-jdk1-0" class="header-anchor">#</a> 6.1 jdk1.0</h3> <p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（Sandbox）机制。如下图所示JDK1.0安全模型</p> <p><a data-fancybox="" title="image-20210401111307060" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/feba838e279b48758261ad8db8dc6f00.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/feba838e279b48758261ad8db8dc6f00.png" alt="image-20210401111307060"></a></p> <h3 id="_6-2-jdk1-1"><a href="#_6-2-jdk1-1" class="header-anchor">#</a> 6.2 jdk1.1</h3> <p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。
因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型</p> <p><a data-fancybox="" title="image-20210401111334192" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/db019e1bf49e40e089c365abadd79b85.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/db019e1bf49e40e089c365abadd79b85.png" alt="image-20210401111334192"></a></p> <h3 id="_6-3-jdk1-2"><a href="#_6-3-jdk1-2" class="header-anchor">#</a> 6.3 jdk1.2</h3> <p>在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型</p> <p><a data-fancybox="" title="image-20210401111403605" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/a18527824ea640118bd8974a91ec8c39.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/a18527824ea640118bd8974a91ec8c39.png" alt="image-20210401111403605"></a></p> <h3 id="_6-4-jdk1-6"><a href="#_6-4-jdk1-6" class="header-anchor">#</a> 6.4 jdk1.6</h3> <p>当前最新的安全机制实现，则引入了域(Domain)的概念。
虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限（Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6)</p> <p><a data-fancybox="" title="image-20210401111444789" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/46cd2487a808405b84d84584ee8d4983.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/46cd2487a808405b84d84584ee8d4983.png" alt="image-20210401111444789"></a></p> <h2 id="七、自定义类加载器"><a href="#七、自定义类加载器" class="header-anchor">#</a> 七、自定义类加载器</h2> <ol><li><p>为什么要自定义类加载器?</p> <ul><li><p>隔离加载类</p> <p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如: Tomcat这类web应用服务器，内部自定义了好几种类加载器，用于隔离同一个web应用服务器上的不同应用程序。（类的仲裁--&gt;类冲突）</p></li> <li><p>修改类加载的方式</p> <p>类的加载模型并非强制，除<code>Bootstrap</code>外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p></li> <li><p>扩展加载源</p></li></ul> <p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p> <ul><li><p>防止源码泄漏</p> <p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p></li></ul></li> <li><p>常见的场景</p> <ul><li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是<code>Java EE</code>和<code>OSGI、JPMS</code>等框架。</li> <li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li></ul></li> <li><p>注意
在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p></li></ol> <p>用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p> <ol><li><p>实现方式
Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。
在自定义ClassLoader 的子类时候，我们常见的会有两种做法:</p> <ul><li>方式一:重写loadclass()方法</li> <li>方式二:重写findClass()方法【推荐】</li></ul></li> <li><p>对比
这两种方法本质上差不多，毕竟<code>loadClass()</code>也会调用<code>findClass()</code>，但是从逻辑上讲我们最好不要直接修改<code>loadClass()</code>的内部逻辑。建议的做法是只在<code>findClass()</code>里重写自定义类的加载方法，根据参数指定类的名字，返回对应的<code>Class</code>对象的引用。
<code>loadClass()</code>这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写<code>loadClass()</code>方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。
当编写好自定义类加载器后，便可以在程序中调用<code>loadClass()</code>方法来实现类加载操作。</p></li> <li><p>说明
其父类加载器是系统类加载器
<code>JVM</code>中的所有类加载都会使用<code>java.lang.ClassLoader.loadClass(String)</code>接口(自定义类加载器并重写<code>java.lang.ClassLoader.loadClass(String)</code>接口的除外)，连<code>JDK</code>的核心类库也不能例外。</p></li></ol> <h2 id="八、java9新特性"><a href="#八、java9新特性" class="header-anchor">#</a> 八、Java9新特性</h2> <p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p> <ol><li><p>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（<code>platform classloader</code>)。可以通过<code>ClassLoader</code>的新方法<code>getPlatformClassLoader()</code>来获取。</p> <p><code>JDK 9</code>时基于模块化进行构建（原来的<code>rt.jar</code> 和<code>tools.jar</code> 被拆分成数十个 <code>JMOD</code> 文件)，其中的<code>Java</code>类库就已天然地满足了可扩展的需求，那自然无须再保留<code>JAVA_HONE\lib\ext</code> 目录，此前使用这个目录或者 <code>java.ext.dirs</code>系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</p></li> <li><p>平台类加载器和应用程序类加载器都不再继承自 <code>java.net.URLClassLoader</code>。
现在<strong>启动类加载器、平台类加载器、应用程序类加载器全都继承于<code>jdk.internal.loader.BuiltinClassLoader</code></strong>。</p> <p><a data-fancybox="" title="image-20210401112508743" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/3d3b22f19c494fe08a605ee9c53a8d49.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/3d3b22f19c494fe08a605ee9c53a8d49.png" alt="image-20210401112508743"></a></p> <p>如果有程序直接依赖了这种继承关系，或者依赖了<code>URLClassLoader</code>类的特定方法，那代码很可能会在 <code>JDK9</code>及更高版本的<code>JDK</code>中崩溃。</p></li> <li><p>在<code>Java 9</code>中，类加载器有了名称。该名称在构造方法中指定，可以通过<code>getName()</code>方法来获取。平台类加载器的名称是<code>platform</code>，应用类加载器的名称是<code>app</code>。类加载器的名称在调试与类加载器相关的问题时会非常有用。</p></li> <li><p>启动类加载器现在是在<code>jvm</code>内部和<code>java</code>类库共同协作实现的类加载器(以前是<code>C++</code>实现)，但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回<code>null</code>，而不会得到<code>BootClassLoader</code>实例。</p></li> <li><p>类加载的委派关系也发生了变动。
当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p> <p><a data-fancybox="" title="image-20210401112747834" href="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/03ed8630b78b4c098db76b638fdbbeb8.png"><img src="http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-01/03ed8630b78b4c098db76b638fdbbeb8.png" alt="image-20210401112747834"></a></p> <p>在Java模块化系统明确规定了三个类加载器负责各自加载的模块</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java/01_ProgrammingBasic/01_JavaLanguage/02_JVM/20_类的加载过程.html" class="prev">
        类的加载过程
      </a></span> <span class="next"><a href="/java/01_ProgrammingBasic/01_JavaLanguage/03_Thread/01_多线程基础.html">
        多线程
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ba474f6b.js" defer></script><script src="/assets/js/2.92f2819f.js" defer></script><script src="/assets/js/49.6417fcf5.js" defer></script>
  </body>
</html>
