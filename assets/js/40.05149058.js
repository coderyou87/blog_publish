(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{448:function(n,t,o){"use strict";o.r(t);var i=o(42),e=Object(i.a)({},(function(){var n=this,t=n.$createElement,o=n._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h1",{attrs:{id:"synchronized与lock的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#synchronized与lock的区别"}},[n._v("#")]),n._v(" Synchronized与Lock的区别")]),n._v(" "),o("ol",[o("li",[o("p",[n._v("原始构成")]),n._v(" "),o("p",[n._v("Synchronized是关键字，属于JVM层面，monitorenter（底层是通过monitor对象来完成，其实wait与notify等方法也依赖于monitor对象，只有在同步块或同步方法中才能调用wait或notify等方法）")]),n._v(" "),o("p",[n._v("Lock是具体类（java.util.concurrent.locks.Lock），是API层面的锁")])]),n._v(" "),o("li",[o("p",[n._v("使用方法")]),n._v(" "),o("p",[n._v("Synchronized 不需要用户手动释放锁，当Synchronized代码执行完毕后，系统会自行让线程释放对象的占用。")]),n._v(" "),o("p",[n._v("ReentrantLock 则需要用户手动释放锁，若没有主动释放锁，就有可能出现死锁。在加锁与释放锁的时候，需要配合try…finally语句来完成。")])]),n._v(" "),o("li",[o("p",[n._v("等待、是否可中断")]),n._v(" "),o("p",[n._v("Synchronized 不可中断，释放锁一般是程序抛出异常或程序正常运行完毕")]),n._v(" "),o("p",[n._v("ReentrantLock 可中断：")]),n._v(" "),o("ol",[o("li",[n._v("设置超时：tryLock(long time, TimeUnit unit)")]),n._v(" "),o("li",[n._v("调用中断方法：lockInterruptibly()")])])]),n._v(" "),o("li",[o("p",[n._v("加锁、是否公平")]),n._v(" "),o("p",[n._v("Synchronized是非公平锁")]),n._v(" "),o("p",[n._v("ReentrantLock两者都可以，默认是非公平锁，可以通过构造方法指定其类型")])]),n._v(" "),o("li",[o("p",[n._v("锁绑定多个条件（Condition）")]),n._v(" "),o("p",[n._v("Synchronized不能绑定条件，只能随机唤醒一个线程或者唤醒所有的线程")]),n._v(" "),o("p",[n._v("ReentrantLock可以使用Condition来实现精准唤醒（一个或一组线程）")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);