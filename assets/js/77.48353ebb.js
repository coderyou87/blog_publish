(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{531:function(a,t,e){"use strict";e.r(t);var s=e(42),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"java内存模型之jmm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型之jmm"}},[a._v("#")]),a._v(" Java内存模型之JMM")]),a._v(" "),e("h2",{attrs:{id:"一、面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、面试题"}},[a._v("#")]),a._v(" 一、面试题")]),a._v(" "),e("ol",[e("li",[a._v("你知道什么事Java内存模型JMM吗？")]),a._v(" "),e("li",[a._v("JMM与Volatile，它们两个之间的关系")]),a._v(" "),e("li",[a._v("JMM有哪些特性？")]),a._v(" "),e("li",[a._v("JMM三大特性是什么？")]),a._v(" "),e("li",[a._v("为什么要有JMM，它为什么出现？作用和功能是什么？")]),a._v(" "),e("li",[e("strong",[a._v("happens-befor先行发生原则，你有了解过吗？")])])]),a._v(" "),e("h2",{attrs:{id:"二、计算机硬件存储体系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、计算机硬件存储体系"}},[a._v("#")]),a._v(" 二、计算机硬件存储体系")]),a._v(" "),e("p",[a._v("计算机存储结构，从本地磁盘到主存到"),e("code",[a._v("CPU")]),a._v("缓存，也就是从硬盘到内存，到"),e("code",[a._v("CPU")]),a._v("。一般对应的程序的操作就是从数据库查数据到内存然后到"),e("code",[a._v("CPU")]),a._v("进行计算")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412220258539",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/65bb368de91243518808758b68b1fd86.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/65bb368de91243518808758b68b1fd86.png",alt:"image-20210412220258539"}})])]),a._v(" "),e("p",[a._v("因为有这么多级的缓存("),e("code",[a._v("cpu")]),a._v("和物理主内存的速度不一致的)，"),e("code",[a._v("CPU")]),a._v("的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412220334501",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/98a191adb1dc461685e7e6dd5926d0b7.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/98a191adb1dc461685e7e6dd5926d0b7.png",alt:"image-20210412220334501"}})])]),a._v(" "),e("p",[e("code",[a._v("Java")]),a._v("虚拟机规范中试图定义一种"),e("code",[a._v("Java")]),a._v("内存模型（"),e("code",[a._v("java Memory Model")]),a._v("，简称"),e("code",[a._v("JMM")]),a._v(") 来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让"),e("code",[a._v("Java")]),a._v("程序在各种平台下都能达到一致的内存访问效果。")]),a._v(" "),e("h2",{attrs:{id:"三、java内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、java内存模型"}},[a._v("#")]),a._v(" 三、Java内存模型")]),a._v(" "),e("p",[e("code",[a._v("JMM")]),a._v("("),e("code",[a._v("Java")]),a._v("内存模型"),e("code",[a._v("Java Memory Model")]),a._v("，简称"),e("code",[a._v("JMM")]),a._v(")本身是一种"),e("strong",[a._v("抽象的")]),a._v("概念，"),e("strong",[a._v("并不真实存在")]),a._v("。它仅仅描述的是一组"),e("strong",[a._v("约定或规范")]),a._v("，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式，并决定一个线程对共享变量的写入，何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的"),e("strong",[a._v("原子性、可见性和有序性")]),a._v("展开的。")]),a._v(" "),e("p",[e("strong",[a._v("原则：")]),a._v("\nJMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的")]),a._v(" "),e("p",[a._v("能干嘛？")]),a._v(" "),e("ol",[e("li",[e("strong",[a._v("通过JMM来实现线程和主内存之间的抽象关系")]),a._v("。")]),a._v(" "),e("li",[a._v("屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。")])]),a._v(" "),e("h2",{attrs:{id:"四、jmm规范下的三大特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、jmm规范下的三大特性"}},[a._v("#")]),a._v(" 四、JMM规范下的三大特性")]),a._v(" "),e("h3",{attrs:{id:"_4-1-可见性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-可见性"}},[a._v("#")]),a._v(" 4.1 可见性")]),a._v(" "),e("p",[e("strong",[a._v("是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更")]),a._v(" ，JMM规定了所有的变量都存储在"),e("strong",[a._v("主内存")]),a._v("中。")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412221019636",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/74ab915591fd4d8f8112cc1aebe425e0.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/74ab915591fd4d8f8112cc1aebe425e0.png",alt:"image-20210412221019636"}})])]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412221053997",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/8c1b4ee905b74bae866fa8e1a723660c.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/8c1b4ee905b74bae866fa8e1a723660c.png",alt:"image-20210412221053997"}})])]),a._v(" "),e("p",[e("strong",[a._v("Java中普通的共享变量不保证可见性")]),a._v('，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现"'),e("strong",[a._v("脏读")]),a._v('"，所以每个线程都有自己的'),e("strong",[a._v("工作内存")]),a._v("，线程自己的工作内存中保存了该线程使用到的变量的"),e("strong",[a._v("主内存副本拷贝")]),a._v("，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412221120387",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/3c52c14deeed4a2681d555209be4dae3.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/3c52c14deeed4a2681d555209be4dae3.png",alt:"image-20210412221120387"}})])]),a._v(" "),e("p",[e("strong",[a._v("线程脏读：如果没有可见性保证")])]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412221141509",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/a4012d585eb24d248041aa85b7c38f0b.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/a4012d585eb24d248041aa85b7c38f0b.png",alt:"image-20210412221141509"}})])]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412221153804",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/c97e491053f54c978673b583c404e626.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/c97e491053f54c978673b583c404e626.png",alt:"image-20210412221153804"}})])]),a._v(" "),e("h3",{attrs:{id:"_4-2-原子性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-原子性"}},[a._v("#")]),a._v(" 4.2 原子性")]),a._v(" "),e("p",[a._v("指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰")]),a._v(" "),e("h3",{attrs:{id:"_4-3-有序性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-有序性"}},[a._v("#")]),a._v(" 4.3 有序性")]),a._v(" "),e("p",[a._v("对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。\n但为了提供性能，编译器和处理器通常会对指令序列进行重新排序。\n指令重排"),e("strong",[a._v("可以保证串行语义一致")]),a._v("，但没有义务保证"),e("strong",[a._v("多线程间的语义也一致")]),a._v('，即可能产生"脏读"，简单说，\n两行以上不相干的代码在执行的时候有可能先执行的不是第一条，'),e("strong",[a._v("不见得是从上到下顺序执行，执行顺序会被优化")]),a._v("。")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412221833998",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/6417f506b84547b5844b8faf639d5f45.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/6417f506b84547b5844b8faf639d5f45.png",alt:"image-20210412221833998"}})])]),a._v(" "),e("p",[a._v("单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。\n处理器在进行重排序时"),e("strong",[a._v("必须要考虑指令之间的数据依赖性")]),a._v("\n多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测")]),a._v(" "),e("p",[e("strong",[a._v("案例：")])]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("mySort")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" x "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("11")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" y "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2")]),a._v("\n    x "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句3")]),a._v("\n    y "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句4")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1234")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2134")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//  1324")]),a._v("\n \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 问题：请问语句4可以重排后变成第一个条吗？")]),a._v("\n")])])]),e("h2",{attrs:{id:"五、jmm规范下的多线程对变量的读写过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、jmm规范下的多线程对变量的读写过程"}},[a._v("#")]),a._v(" 五、JMM规范下的多线程对变量的读写过程")]),a._v(" "),e("p",[a._v("读取过程：")]),a._v(" "),e("p",[a._v("由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而"),e("strong",[a._v("Java内存模型中规定所有变量都存储在主内存")]),a._v("，主内存是共享内存区域，所有线程都可以访问，"),e("strong",[a._v("但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存")]),a._v("，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的"),e("strong",[a._v("变量副本拷贝")]),a._v("，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412223015377",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/a2dc7483762c4a7b88f569f51b753b29.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/a2dc7483762c4a7b88f569f51b753b29.png",alt:"image-20210412223015377"}})])]),a._v(" "),e("p",[e("strong",[a._v("JMM定义了线程和主内存之间的抽象关系")]),a._v("\n1 线程之间的共享变量存储在主内存中(从硬件角度来说就是内存条)\n2 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本(从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等)")]),a._v(" "),e("p",[e("strong",[a._v("总结：")])]),a._v(" "),e("ol",[e("li",[a._v("我们定义的所有共享变量都储存在物理主内存中")]),a._v(" "),e("li",[a._v("每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)")]),a._v(" "),e("li",[a._v("线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)")]),a._v(" "),e("li",[a._v("不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)")])]),a._v(" "),e("h2",{attrs:{id:"六、jmm规范下的多线程先行发生原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、jmm规范下的多线程先行发生原则"}},[a._v("#")]),a._v(" 六、JMM规范下的多线程先行发生原则")]),a._v(" "),e("p",[a._v("在JMM中，如果一个操作执行的结果需要对另一个操作可见性，或者 代码重排序，那么这两个操作之间必须存在happens-before关系。")]),a._v(" "),e("p",[e("strong",[a._v("案例：")])]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412223442010",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/9663665a21c445e985f1053349d19cca.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/9663665a21c445e985f1053349d19cca.png",alt:"image-20210412223442010"}})])]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20210412223453173",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/460d6b42c3744c0f87aaa8049d085b90.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-04-12/460d6b42c3744c0f87aaa8049d085b90.png",alt:"image-20210412223453173"}})])]),a._v(" "),e("h3",{attrs:{id:"_6-1-先行发生原则说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-先行发生原则说明"}},[a._v("#")]),a._v(" 6.1 先行发生原则说明")]),a._v(" "),e("p",[a._v("如果Java内存模型中所有的有序性都仅靠"),e("code",[a._v("volatile")]),a._v("和"),e("code",[a._v("synchronized")]),a._v("来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写"),e("code",[a._v("Java")]),a._v("并发代码的时候并没有察觉到这一点。")]),a._v(" "),e("p",[e("strong",[a._v("我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下")]),a._v(" "),e("strong",[a._v("有一个“先行发生”(Happens-Before)的原则限制和规矩")])]),a._v(" "),e("p",[a._v("这个原则非常重要：\n"),e("strong",[a._v("它是判断数据是否存在竞争，线程是否安全的非常有用的手段")]),a._v("。依赖这个原则，我们可以通过几条简单规则一揽子解决"),e("strong",[a._v("并发环境下两个操作之间是否可能存在冲突的所有问题")]),a._v("，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。")]),a._v(" "),e("h3",{attrs:{id:"_6-2-happens-before总原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-happens-before总原则"}},[a._v("#")]),a._v(" 6.2 happens-before总原则")]),a._v(" "),e("ol",[e("li",[a._v("如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。")]),a._v(" "),e("li",[a._v("两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的"),e("strong",[a._v("结果一致")]),a._v("，那么这种重排序"),e("strong",[a._v("并不非法")]),a._v("。")])]),a._v(" "),e("h3",{attrs:{id:"_6-3-happens-before的8条细则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-happens-before的8条细则"}},[a._v("#")]),a._v(" 6.3 happens-before的8条细则")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("次序规则")]),a._v(" "),e("p",[a._v("一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作；前一个操作的结果可以被后续的操作获取。前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1。")])]),a._v(" "),e("li",[e("p",[a._v("锁定规则")]),a._v(" "),e("p",[a._v("一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作；上一个线程先unlock，下一个线程才能对同一把锁lock")])]),a._v(" "),e("li",[e("p",[a._v("Volatile变量规则")]),a._v(" "),e("p",[a._v("对一个volatile变量的写操作先行发生于后面对这个变量的读操作（"),e("strong",[a._v("先写后读")]),a._v("），"),e("strong",[a._v("前面的写对后面的读是可见的")]),a._v("，这里的“后面”同样是指时间上的先后。")])]),a._v(" "),e("li",[e("p",[a._v("传递规则")]),a._v(" "),e("p",[a._v("如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；")])]),a._v(" "),e("li",[e("p",[a._v("线程启动规则")]),a._v(" "),e("p",[e("code",[a._v("Thread Start Rule")]),a._v("，"),e("code",[a._v("Thread")]),a._v("对象的"),e("code",[a._v("start()")]),a._v("方法先行发生于此线程的每一个动作")])]),a._v(" "),e("li",[e("p",[a._v("线程中断规则")]),a._v(" "),e("p",[e("code",[a._v("Thread Interrupt Rule")]),a._v("，对线程"),e("code",[a._v("interrupt()")]),a._v("方法的调用先行发生于被中断线程的代码检测到中断事件的发生（先中断，才能检测到）；可以通过"),e("code",[a._v("Thread.interrupted()")]),a._v("检测到是否发生中断")])]),a._v(" "),e("li",[e("p",[a._v("线程终止规则")]),a._v(" "),e("p",[e("code",[a._v("Thread Termination Rule")]),a._v("，线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过"),e("code",[a._v("Thread::join()")]),a._v("方法是否结束、"),e("code",[a._v("Thread::isAlive()")]),a._v("的返回值等手段检测线程是否已经终止执行。")])]),a._v(" "),e("li",[e("p",[a._v("对象终结规则")]),a._v(" "),e("p",[e("code",[a._v("Finalizer Rule")]),a._v("，一个对象的初始化完成（构造函数执行结束）先行发生于它的"),e("code",[a._v("finalize()")]),a._v("方法的开始，对象没有完成初始化之前，是不能调用"),e("code",[a._v("finalized()")]),a._v("方法的")])])]),a._v(" "),e("h3",{attrs:{id:"_6-4-案例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-案例"}},[a._v("#")]),a._v(" 6.4 案例")]),a._v(" "),e("p",[e("strong",[a._v("代码：")])]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HappenBeforeDemo")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    \n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("setValue")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("value "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("getValue")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("    \n")])])]),e("p",[a._v("假设存在线程"),e("code",[a._v("A")]),a._v("和"),e("code",[a._v("B")]),a._v("，线程"),e("code",[a._v("A")]),a._v("先（时间上的先后）调用了"),e("code",[a._v("setValue(1)")]),a._v("，然后线程B调用了同一个对象的"),e("code",[a._v("getValue()")]),a._v("，那么线程"),e("code",[a._v("B")]),a._v("收到的返回值是什么？")]),a._v(" "),e("p",[a._v("我们就这段简单的代码一次分析"),e("code",[a._v("happens-before")]),a._v("的规则（规则"),e("code",[a._v("5、6、7、8")]),a._v(" 可以忽略，因为他们和这段代码毫无关系）：")]),a._v(" "),e("ol",[e("li",[a._v("由于两个方法是由不同的线程调用，不在同一个线程中，所以肯定不满足程序次序规则；")]),a._v(" "),e("li",[a._v("两个方法都没有使用锁，所以不满足锁定规则；")]),a._v(" "),e("li",[a._v("变量不是用"),e("code",[a._v("volatile")]),a._v("修饰的，所以"),e("code",[a._v("volatile")]),a._v("变量规则不满足；")]),a._v(" "),e("li",[a._v("传递规则肯定不满足；")])]),a._v(" "),e("p",[a._v("所以我们无法通过"),e("code",[a._v("happens-before")]),a._v("原则推导出线程"),e("code",[a._v("A happens-before")]),a._v("线程"),e("code",[a._v("B")]),a._v("，虽然可以确认在时间上线程"),e("code",[a._v("A")]),a._v("优先于线程"),e("code",[a._v("B")]),a._v("指定，\n但就是无法确认线程"),e("code",[a._v("B")]),a._v("获得的"),e("strong",[a._v("结果是什么")]),a._v("，所以这段代码不是线程安全的。"),e("strong",[a._v("那么怎么修复这段代码呢？")])]),a._v(" "),e("p",[e("strong",[a._v("修复：")])]),a._v(" "),e("ol",[e("li",[a._v("把"),e("code",[a._v("getter/setter")]),a._v("方法都定义为"),e("code",[a._v("synchronized")]),a._v("方法")]),a._v(" "),e("li",[a._v("把"),e("code",[a._v("value")]),a._v("定义为"),e("code",[a._v("volatile")]),a._v("变量，由于"),e("code",[a._v("setter")]),a._v("方法对"),e("code",[a._v("value")]),a._v("的修改不依赖"),e("code",[a._v("value")]),a._v("的原值，满足"),e("code",[a._v("volatile")]),a._v("关键字使用场景")])])])}),[],!1,null,null,null);t.default=v.exports}}]);