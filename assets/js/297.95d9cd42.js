(window.webpackJsonp=window.webpackJsonp||[]).push([[297],{694:function(e,v,a){"use strict";a.r(v);var s=a(42),l=Object(s.a)({},(function(){var e=this,v=e.$createElement,a=e._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"redis-配置文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-配置文件"}},[e._v("#")]),e._v(" Redis 配置文件")]),e._v(" "),a("h2",{attrs:{id:"一、网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、网络"}},[e._v("#")]),e._v(" 一、网络")]),e._v(" "),a("ol",[a("li",[e._v("bind\nbind用于配置允许连接Redis的网络地址\n默认配置为"),a("code",[e._v("127.0.0.1")]),e._v("，只能在Redis本机访问，不能远程访问\n如果将bind删除或直接注释，则Redis会接受所有可用网络的连接请求")]),e._v(" "),a("li",[e._v("protected-mode\n保护模式，默认开启。\n关闭保护模式后，外部可用网络能够直接访问Redis\n开启保护模式后，配置bind或使用密码后才能访问Redis")]),e._v(" "),a("li",[e._v("port\nRedis监听的端口，默认是6379")]),e._v(" "),a("li",[e._v("timeout\n当客户端闲置一定时间后，关闭该连接。如果值为0，则表示禁止该功能。默认禁止")])]),e._v(" "),a("h2",{attrs:{id:"二、通用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、通用"}},[e._v("#")]),e._v(" 二、通用")]),e._v(" "),a("ol",[a("li",[e._v("daemonize\n是否以守护进程的方式启动Redis，默认为no\n设置为yes后，Redis将以守护进行（后台运行）的方式运行")]),e._v(" "),a("li",[e._v("pidfile\n进程Id文件，默认为“/var/run/redis_6379.pid”\n当Redis以守护进程模式启动时，会创建该文件，关闭Redis，会删除该文件\n如果不是以守护进程启动Redis，则不会创建或删除该文件。")]),e._v(" "),a("li",[e._v("loglevel\n日志级别，默认为notice。可选值有：debug，verbose，notice，warning")]),e._v(" "),a("li",[e._v("logfile\n日志文件\n如果配置为空字符串，则是标准输出\n如果配置为空字符串，且是以守护进程模式启动Redis，则会将日志输出到"),a("code",[e._v("/dev/null")])]),e._v(" "),a("li",[e._v("databases\n设置数据库个数，默认是16个\n默认使用的数据库是第0个，可以使用"),a("code",[e._v("select dbid")]),e._v("来切换数据库")]),e._v(" "),a("li",[e._v("save\n持久化设置，默认情况下，有三种情况会将数据写入磁盘（900秒，1次变更；300秒，10次变更；60秒，10000次变更）")]),e._v(" "),a("li",[e._v("stop-writes-on-bgsave-error\n如果持久化方案是rdb，在最后一次保存失败后，Redis将停止接受写操作，Redis保存进程重新启动工作后，Redis将自动允许写操作")]),e._v(" "),a("li",[e._v("dbfilename\nRBD持久化方案的文件名称，默认是"),a("code",[e._v("dump.rdb")])]),e._v(" "),a("li",[e._v("dir\n指定备份的文件路径，备份文件名称就是"),a("code",[e._v("dbfilename")]),e._v("对应的名称")])]),e._v(" "),a("h2",{attrs:{id:"三、主从复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、主从复制"}},[e._v("#")]),e._v(" 三、主从复制")]),e._v(" "),a("ol",[a("li",[e._v("replicaof "),a("masterip",[a("masterport",[e._v("\n主从同步配置，在从节点中配置主节点的地址")])],1)],1),e._v(" "),a("li",[e._v("masterauth "),a("master-password",[e._v("\n主节点的密码")])],1),e._v(" "),a("li",[e._v("replica-serve-stale-data\n当一个从节点与主节点失去连接的时候，或者同步正在进行中，slave的行为可能有两种：\n"),a("ol",[a("li",[e._v("如果replica-serve-stale-data设置为yes，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值得空数据")]),e._v(" "),a("li",[e._v("如果replica-serve-stale-data设置为no，slave会向客户端回复“正在从master同步数据”来处理各种请求")])])]),e._v(" "),a("li",[e._v("replica-read-only\n从节点是否只读")]),e._v(" "),a("li",[e._v("repl-diskless-sync\n数据同步策略\n当一个新的slave加入后，需要进行一次全量的数据同步。同步策略主要有：\n"),a("ol",[a("li",[e._v("基于硬盘（disk-backed）：master创建一个新进程dump RDB，然后由父进程传输给slave。在dump RDB完成后，可以同时服务多个slave")]),e._v(" "),a("li",[e._v("基于socket（diskless）：master创建一个新进程直接dump RDB到slave的socket，不进过主进程，不进过磁盘。基于socket，只能单个进行\n默认情况下，使用的是基于磁盘；如果网络较快，也可以使用基于socket")])])]),e._v(" "),a("li",[e._v("repl-diskless-sync-delay\n如果使用非磁盘同步，可以配置同步延迟时间，以等待master产生子进程通过socket传输RDB数据给slave。默认值为5秒，设置为0，则每次传输无延迟")]),e._v(" "),a("li",[e._v("repl-ping-replica-period\nslave根据指定的时间间隔向master发送ping请求")]),e._v(" "),a("li",[e._v("slave-priority\n设置slave的优先级，默认为100。在master不能工作的时候，sentinel会从可用的slave中选择一个节点作为master，优先级数值小的slave会被优先考虑作为master\n如果一个slave的优先级为0，则不会被提升为master")])]),e._v(" "),a("h2",{attrs:{id:"四、安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、安全"}},[e._v("#")]),e._v(" 四、安全")]),e._v(" "),a("ol",[a("li",[e._v("requirepass\n设置访问密码")]),e._v(" "),a("li",[e._v("rename-command\n对命令重命名，可以将一个危险的命令重命名为其他名称。如果将一个命令重命名为空字符串，则是禁用此命令")])]),e._v(" "),a("h2",{attrs:{id:"五、连接限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、连接限制"}},[e._v("#")]),e._v(" 五、连接限制")]),e._v(" "),a("ol",[a("li",[e._v("maxclients\n设置最大的连接数")])]),e._v(" "),a("h2",{attrs:{id:"六、内存管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、内存管理"}},[e._v("#")]),e._v(" 六、内存管理")]),e._v(" "),a("ol",[a("li",[e._v("maxmemory\n设置最大内存")]),e._v(" "),a("li",[e._v("maxmemory-policy\n最大内存策略。当内存使用达到最大值时，所采取的策略，默认是noeviction。\n"),a("ul",[a("li",[e._v("volatile-lru：根据LUR算法，删除过期Key")]),e._v(" "),a("li",[e._v("allkeys-lru：根据LUR算法，删除任何key")]),e._v(" "),a("li",[e._v("volatile-random：随机删除过期key")]),e._v(" "),a("li",[e._v("allkeys-random：随机删除任意key")]),e._v(" "),a("li",[e._v("volatile-ttl：移除即将过期的key")]),e._v(" "),a("li",[e._v("noeviction：不删除任何key，向客户端返回一个错误（默认）")])])])]),e._v(" "),a("h2",{attrs:{id:"七、appendonly"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、appendonly"}},[e._v("#")]),e._v(" 七、AppendOnly")]),e._v(" "),a("ol",[a("li",[e._v("appendonly\n是否开启appendonly，一种数据持久化方案")]),e._v(" "),a("li",[e._v('appendfilename\n持久化文件名称，默认文件名为："appendonly.aof"')]),e._v(" "),a("li",[e._v("appendfsync\n持久化策略，有三个选择项：\n"),a("ul",[a("li",[e._v("always：及时持久化")]),e._v(" "),a("li",[e._v("everysec：每秒写入一次")]),e._v(" "),a("li",[e._v("no：不会立刻刷，只有在操作系统需要刷的时候再刷。")])])])]),e._v(" "),a("h2",{attrs:{id:"八、集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、集群"}},[e._v("#")]),e._v(" 八、集群")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("cluster-enabled")]),e._v(" "),a("p",[e._v("是否开启集群，只有开启后，当前节点才能作为集群的一部分")])]),e._v(" "),a("li",[a("p",[e._v("cluster-config-file nodes-6379.conf")]),e._v(" "),a("p",[e._v("集群配置文件")])]),e._v(" "),a("li",[a("p",[e._v("cluster-node-timeout")]),e._v(" "),a("p",[e._v("设置集群节点超时时间，超时的节点将被视为不可用状态")])]),e._v(" "),a("li",[a("p",[e._v("cluster-slave-validity-factor")]),e._v(" "),a("p",[e._v("如果数据太旧，集群中的不可用master的slave节点会避免成为备用master节点。如果slave和master失联时间超过（nodel-timeout * slave-validity-factor）+ repl-ping-period，则不会被提升为master节点。")]),e._v(" "),a("p",[e._v("如果 slave-validity-factor的值比较大，则允许包含过旧数据的slave成为master，如果比较小，则可能会阻止集群选举出master节点。")])]),e._v(" "),a("li",[a("p",[e._v("cluster-migration-barrier")]),e._v(" "),a("p",[e._v("该属性可以保证集群中不会出现裸奔的主节点（没有从节点的主节点），当某个主节点的从节点宕机后，集群会从其他富余的主节点上分配一个从节点过来，确保每个主节点都有至少一个从节点，不至于因为主节点宕机而没有从节点来替换。该配置的默认值是1")])])])])}),[],!1,null,null,null);v.default=l.exports}}]);