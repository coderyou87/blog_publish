(window.webpackJsonp=window.webpackJsonp||[]).push([[268],{469:function(a,t,e){"use strict";e.r(t);var r=e(42),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("[toc]")]),a._v(" "),e("h1",{attrs:{id:"jvm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),e("p",[a._v("JVM (Java Virtual Meachine)，即Java虚拟机，是Java运行时的环境。")]),a._v(" "),e("h2",{attrs:{id:"一、java内存区域与内存溢出异常"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、java内存区域与内存溢出异常"}},[a._v("#")]),a._v(" 一、Java内存区域与内存溢出异常")]),a._v(" "),e("h3",{attrs:{id:"_1-1-java内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-java内存模型"}},[a._v("#")]),a._v(" 1.1 Java内存模型")]),a._v(" "),e("p",[a._v("​\t\tJMM（Java内存模型 Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一种规范或规则，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。")]),a._v(" "),e("p",[a._v("JMM关于同步的规定：")]),a._v(" "),e("blockquote",[e("ol",[e("li",[a._v("线程解锁前，必须把共享变量的值刷新回主内存")]),a._v(" "),e("li",[a._v("线程加锁前，必须读取主内存的最新值到自己的工作内存")]),a._v(" "),e("li",[a._v("加锁与解锁是同一把锁")])])]),a._v(" "),e("p",[a._v("​\t\t由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都是可以访问的，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量拷贝副本，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下：")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/db476f38d8db4f1f875222e617b7430d.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/db476f38d8db4f1f875222e617b7430d.png",alt:"img"}})])]),a._v(" "),e("h3",{attrs:{id:"_1-2-运行时数据区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-运行时数据区"}},[a._v("#")]),a._v(" 1.2 运行时数据区")]),a._v(" "),e("p",[a._v("​\t\tJava虚拟机在执行Java程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/ea7074b957f44f6f87d9bcd7819b5ab9.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/ea7074b957f44f6f87d9bcd7819b5ab9.png",alt:"img"}})])]),a._v(" "),e("p",[a._v("注意：")]),a._v(" "),e("ol",[e("li",[a._v("方法区与堆是所有线程共享的数据区")]),a._v(" "),e("li",[a._v("Java栈、本地方法栈以及程序计数器是线程隔离的数据区")])]),a._v(" "),e("h4",{attrs:{id:"_1-2-1-程序计数器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-程序计数器"}},[a._v("#")]),a._v(" 1.2.1 程序计数器")]),a._v(" "),e("p",[a._v("​\t\t程序计数器（"),e("code",[a._v("Program Counter Register")]),a._v("）是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行动指示器。在虚拟机的概念模型中，字节码解析器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。")]),a._v(" "),e("p",[a._v("​\t\t由于"),e("code",[a._v("Java")]),a._v("虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来完成的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程之间计数器互不影响，独立存储。我们称这类区域为“线程私有”的内存。")]),a._v(" "),e("p",[a._v("​\t\t如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码执行的地址。如果正在执行的是Navite方法，这个计数器值则为空（"),e("code",[a._v("Undefined")]),a._v("）。此内存区域是唯一一个在"),e("code",[a._v("Java")]),a._v("虚拟机规范中没有规定任何"),e("code",[a._v("OutOfMemoryError")]),a._v("情况的区域。")]),a._v(" "),e("h4",{attrs:{id:"_1-2-2-java虚拟机栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-java虚拟机栈"}},[a._v("#")]),a._v(" 1.2.2 Java虚拟机栈")]),a._v(" "),e("p",[a._v("​\t\tJava虚拟机栈（"),e("code",[a._v("Java Virtual Machine Stacks")]),a._v("）与程序计数器一样，都是线程是有的。它的生命周期与线程相同。虚拟机栈描述的是"),e("code",[a._v("Java")]),a._v("方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（"),e("code",[a._v("Stack Frame")]),a._v("）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。")]),a._v(" "),e("p",[a._v("​\t\t局部变量表存放了编译期可知的各种基本数据类型（"),e("code",[a._v("boolean、byte、char、short、int、float、long、double")]),a._v("）、对象引用（"),e("code",[a._v("reference")]),a._v("类型，它不等同与对象本身，可能是一个指向对象起始地址的引用地址，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和"),e("code",[a._v("returnAddress")]),a._v("类型（指向了一条字节码指令的地址）。")]),a._v(" "),e("p",[a._v("​\t\t其中64位长度的"),e("code",[a._v("long")]),a._v("和"),e("code",[a._v("double")]),a._v("类型的数据会占用2个局部变量空间（"),e("code",[a._v("slot")]),a._v("），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。")]),a._v(" "),e("p",[a._v("​\t\t在"),e("code",[a._v("Java")]),a._v("虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出"),e("code",[a._v("StackOverflowError")]),a._v("异常；如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，就会抛出"),e("code",[a._v("OutOfMemoryError")]),a._v("异常。")]),a._v(" "),e("h4",{attrs:{id:"_1-2-3-本地方法栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-本地方法栈"}},[a._v("#")]),a._v(" 1.2.3 本地方法栈")]),a._v(" "),e("p",[a._v("​\t\t本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相识的，它们之间的区别不会是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。Sun HostSpot直接将本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。")]),a._v(" "),e("h4",{attrs:{id:"_1-2-4-java堆"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-4-java堆"}},[a._v("#")]),a._v(" 1.2.4 Java堆")]),a._v(" "),e("p",[a._v("​\t\tJava堆（Java Heap）是Java虚拟机多管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数据都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也逐渐变得不是那么“绝对”了。")]),a._v(" "),e("p",[a._v("​\t\tJava堆事垃圾收集器管理的主要区域。因此很多时候也被称为“GC堆”（Garbage Collected Heap）。从内存回收的角度看，Java堆可以分为新生代、老年代、永久代（Jdk1.8后取消永久代、替换的是元数据区）、新生代还可以分为Eden、From Survivor、To Survivor空间等。从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。")]),a._v(" "),e("p",[a._v("​\t\t根据Java虚拟机规范，Java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可。在实现时，既可以实现固定大小的，也可以是可扩展的，扩展时常用的两个命令是-Xmx、-Xms。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。")]),a._v(" "),e("h4",{attrs:{id:"_1-2-5-方法区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-5-方法区"}},[a._v("#")]),a._v(" 1.2.5 方法区")]),a._v(" "),e("p",[a._v("​\t\t方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。")]),a._v(" "),e("p",[a._v("​\t\t在HotSpot中，使用了永久代来实现方法区。因为方法区存放的数据时不容易变动的，因此在HotSpot中也被称为永久代，但是有些虚拟机中并没有永久代这个说法。指定永久代空间大小的方法：-XX:MaxPerSize。在Jdk1.7中，将原本在永久代的字符串常量池移除了。在Jdk1.8中，放弃了永久代，使用了元空间（在本地内存中）。")]),a._v(" "),e("p",[a._v("​\t\t在永久代中的垃圾回收，主要针对常量池的回收和类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。")]),a._v(" "),e("h4",{attrs:{id:"_1-2-6-运行时常量池"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-6-运行时常量池"}},[a._v("#")]),a._v(" 1.2.6 运行时常量池")]),a._v(" "),e("p",[a._v("​\t\t运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息时常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。")]),a._v(" "),e("p",[a._v("​\t\tJava虚拟机对Class文件的每一部分的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。")]),a._v(" "),e("p",[a._v("​\t\t运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是String类的intern()方法。")]),a._v(" "),e("p",[a._v("​\t\t既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。")]),a._v(" "),e("h4",{attrs:{id:"_1-2-7-直接内存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-7-直接内存"}},[a._v("#")]),a._v(" 1.2.7 直接内存")]),a._v(" "),e("p",[a._v("​\t\t直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK1.4中加入的NIO类，引入了一种基于通道与缓冲区的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。在JDK1.8中的元空间也存在于直接内存中。既然都是内存，就有可能出现OutOfMemoryError异常。")]),a._v(" "),e("h2",{attrs:{id:"二、类加载机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、类加载机制"}},[a._v("#")]),a._v(" 二、类加载机制")]),a._v(" "),e("h2",{attrs:{id:"三、垃圾回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、垃圾回收"}},[a._v("#")]),a._v(" 三、垃圾回收")]),a._v(" "),e("h3",{attrs:{id:"_3-1-判断对象是否活着"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-判断对象是否活着"}},[a._v("#")]),a._v(" 3.1 判断对象是否活着")]),a._v(" "),e("h4",{attrs:{id:"_3-1-1-引用计数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-引用计数"}},[a._v("#")]),a._v(" 3.1.1 引用计数")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/61cd7adc636640008aee663744d63116.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/61cd7adc636640008aee663744d63116.png",alt:"img"}})])]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/d321289e664a47048feb6bb7a75df6fa.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/d321289e664a47048feb6bb7a75df6fa.png",alt:"img"}})])]),a._v(" "),e("p",[a._v("3.1.2 可达性分析法")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/86c0eeb049d042828ea1daea48d9674f.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/86c0eeb049d042828ea1daea48d9674f.png",alt:"img"}})])]),a._v(" "),e("p",[a._v("Java中可以作为GC Root的对象")]),a._v(" "),e("ol",[e("li",[a._v("虚拟机栈（栈帧中的局部变量区或局部变量表）中引用的对象")]),a._v(" "),e("li",[a._v("方法区中的类静态属性引用的对象")]),a._v(" "),e("li",[a._v("方法区中常量引用的对象")]),a._v(" "),e("li",[a._v("本地方法栈中JNI（Native方法）引用的对象")])]),a._v(" "),e("h3",{attrs:{id:"_3-2-垃圾收集算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-垃圾收集算法"}},[a._v("#")]),a._v(" 3.2 垃圾收集算法")]),a._v(" "),e("p",[a._v("3.2.1 引用计数")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/ef7093e54b20413d82a89c8000ea2161.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/ef7093e54b20413d82a89c8000ea2161.png",alt:"img"}})])]),a._v(" "),e("p",[a._v("3.2.2 复制算法")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/43fb1c24ab334a8d8176aa36f66e3097.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/43fb1c24ab334a8d8176aa36f66e3097.png",alt:"img"}})])]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/60d9206135db451b8525f91e50d67c90.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/60d9206135db451b8525f91e50d67c90.png",alt:"img"}})])]),a._v(" "),e("p",[a._v("3.2.3 标记整理")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/1d5e4e03edb0484488f196b0ebdf3e4e.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/1d5e4e03edb0484488f196b0ebdf3e4e.png",alt:"img"}})])]),a._v(" "),e("p",[a._v("3.2.4 标记清除")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/3cb476d11d52487984e0b4bd237138d4.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/3cb476d11d52487984e0b4bd237138d4.png",alt:"img"}})])]),a._v(" "),e("h3",{attrs:{id:"_3-3-垃圾收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-垃圾收集器"}},[a._v("#")]),a._v(" 3.3 垃圾收集器")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/7929942f0adb4e878eeb3dd42536e13c.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/7929942f0adb4e878eeb3dd42536e13c.png",alt:"img"}})])]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"img",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/553d12ec942741e387ac4ed165616402.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-07-12/553d12ec942741e387ac4ed165616402.png",alt:"img"}})])]),a._v(" "),e("ol",[e("li",[e("p",[a._v("Serial：它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程。所以不适合服务器环境。")])]),a._v(" "),e("li",[e("p",[a._v("Parallel：多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理首台处理等弱交互场")])]),a._v(" "),e("li",[e("p",[a._v("CMS：用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程。互联网公司使用比较多，适用于对响应时间有要求的场景。")])]),a._v(" "),e("li",[e("p",[a._v("CMS：用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程。互联网公司使用比较多，适用于对响应时间有要求的场景。")])])]),a._v(" "),e("h3",{attrs:{id:"_3-4-内存分配与回收策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-内存分配与回收策略"}},[a._v("#")]),a._v(" 3.4 内存分配与回收策略")])])}),[],!1,null,null,null);t.default=v.exports}}]);