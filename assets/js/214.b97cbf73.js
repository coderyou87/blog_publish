(window.webpackJsonp=window.webpackJsonp||[]).push([[214],{629:function(e,o,t){"use strict";t.r(o);var l=t(42),v=Object(l.a)({},(function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"k8s介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#k8s介绍"}},[e._v("#")]),e._v(" k8s介绍")]),e._v(" "),t("p",[e._v("组件说明：")]),e._v(" "),t("ul",[t("li",[e._v("ApiServer：所有服务访问的统一入口")]),e._v(" "),t("li",[e._v("ControllerManager：维持副本期望数目")]),e._v(" "),t("li",[e._v("Scheduler：负责介绍任务，选择合适的节点进行分配任务")]),e._v(" "),t("li",[e._v("Etcd：键值对数据库，存储k8s集群中所有重要的信息（可持久化）")]),e._v(" "),t("li",[e._v("Kubelet：直接跟容器引擎交互实现容器的生命周期管理")]),e._v(" "),t("li",[e._v("Kube-proxy：复制写入规则至Iptables、IPVS，实现服务映射访问")]),e._v(" "),t("li",[e._v("Coredns：可以为集群中的svc创建一个域名ip的对应关系解析")]),e._v(" "),t("li",[e._v("DashBoard：为k8s集群提供的一个web访问界面")]),e._v(" "),t("li",[e._v("Ingress Controller：官方只提供了四层代理，该组件能提供七层代理")]),e._v(" "),t("li",[e._v("Prometheus：提供一个k8s集群的监控平台")]),e._v(" "),t("li",[e._v("Elk：提供k8s日志统一分析平台")])]),e._v(" "),t("h2",{attrs:{id:"一、pod介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、pod介绍"}},[e._v("#")]),e._v(" 一、Pod介绍")]),e._v(" "),t("p",[e._v("分类：")]),e._v(" "),t("ol",[t("li",[e._v("自主式Pod")]),e._v(" "),t("li",[e._v("控制器管理的Pod")])]),e._v(" "),t("p",[e._v("ReplicationController：用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代；二如果异常多出来的容器也会被自动回收。在新版本的Kubernetes中建议使用ReplicaSet来取代ReplicationController")]),e._v(" "),t("p",[e._v("ReplicaSet：跟ReplicationController没有本质的区别，只是名字不同，并且ReplicaSet支持集合式的selector")]),e._v(" "),t("p",[e._v("Deployment：最然ReplicaSet可以独立使用，但一般建议使用Deployment来自动管理ReplicaSet，这样就无需担心跟其他机制的不兼容问题（ReplicaSet不支持rolling-update，但是Deployment支持）")]),e._v(" "),t("p",[e._v("HPA：Horizontal Pod Autoscaling，仅适用与Deployment和ReplicaSet，在V1版本中仅支持Pod的CPU利用率缩容，在v1alpha版本中，支持根据内存和用户自动一的metric扩缩容。")]),e._v(" "),t("p",[e._v("StatefulSet：是为了解决有状态服务的问题（Deployment和ReplicaSet是为了解决无状态服务而设计的），应用场景包括：")]),e._v(" "),t("ul",[t("li",[e._v("未定的持久化存储，即Pod重新调度后还能访问到相同的持久化数据，基于PVC来实现")]),e._v(" "),t("li",[e._v("未定的网络标志，即Pod重新调度后，其PodName和PodHost不变，基于headless Service（即没有Cluster Ip的service）来实现")]),e._v(" "),t("li",[e._v("有序部署，有序扩展，即Pod是有序的（扩展的时候从0到N-1 ），在部署或者扩展的时候要根据定义的顺序依次进行，如果需要当前的Pod运行，那么之前的Pod必须处于Running和Ready状态，基于init containers来实现")]),e._v(" "),t("li",[e._v("有序收缩，删除的时候从N-1到0")])]),e._v(" "),t("p",[e._v("DaemonSet：确保全部或者一些Node上运行一个Pod的副本。当有Node加入集群时，也会为他们新增一个Pod，当有Noe从集群移除时，这些Pod也会被回收。删除DaemonSet将会删除它创建的所有Pod。使用DaemonSet的一些用法：")]),e._v(" "),t("ul",[t("li",[e._v("运行集群存储daemon，例如在每个Node上运行glusterd、ceph")]),e._v(" "),t("li",[e._v("在每个Node上运行日志收集daemon，例如fluentd、logstash")]),e._v(" "),t("li",[e._v("在每个Node上运行监控daemon，例如Prometheus Node Exporter")])]),e._v(" "),t("p",[e._v("Job：负责批量处理任务，即执行一次的任务，它保证批处理任务的一个或多个Pod成功结束")]),e._v(" "),t("p",[e._v("Cron Job：管理基于时间的Job")]),e._v(" "),t("ul",[t("li",[e._v("在指定时间运行一次")]),e._v(" "),t("li",[e._v("周期性运行")])]),e._v(" "),t("h2",{attrs:{id:"二、网络通讯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、网络通讯"}},[e._v("#")]),e._v(" 二、网络通讯")]),e._v(" "),t("p",[e._v("Kubernetes的网络模型假定了所有Pod都在一个可以直接连通的扁平的网络空间中，这早GCE（Google Compute Engine）里面是现成的网络模型，Kubernetes假定这个网络已经存在。而在私有云里搭建Kubernetes集群，就不能假定这个网络已经存在。需要自己实现这个网络假设，将不同节点上的Docker同期之间的相互访问先打通，然后运行Kubernetes。")])])}),[],!1,null,null,null);o.default=v.exports}}]);