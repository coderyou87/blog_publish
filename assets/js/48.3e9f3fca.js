(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{397:function(a,v,_){"use strict";_.r(v);var t=_(42),s=Object(t.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"类的加载过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类的加载过程"}},[a._v("#")]),a._v(" 类的加载过程")]),a._v(" "),_("h2",{attrs:{id:"一、概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、概述"}},[a._v("#")]),a._v(" 一、概述")]),a._v(" "),_("p",[a._v("在Java中数据类型分为"),_("strong",[a._v("基本数据类型和引用数据类型")]),a._v("。**基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。**加载类、接口、注解和枚举的过程都称为类的加载。\n按照"),_("code",[a._v("Java")]),a._v("虚拟机规范，从"),_("code",[a._v("class")]),a._v("文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段:")]),a._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"image-20210330103305252",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/9f2e711fe595498a8f4f61ee4d6b4d81.png"}},[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/9f2e711fe595498a8f4f61ee4d6b4d81.png",alt:"image-20210330103305252"}})])]),a._v(" "),_("p",[a._v("面试题：")]),a._v(" "),_("ul",[_("li",[a._v("什么是类的加载")]),a._v(" "),_("li",[a._v("哪些情况下会触发类的加载")]),a._v(" "),_("li",[a._v("JVM加载类的过程")]),a._v(" "),_("li",[a._v("JVM的类加载机制是什么")])]),a._v(" "),_("h2",{attrs:{id:"二、加载阶段（loading）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、加载阶段（loading）"}},[a._v("#")]),a._v(" 二、加载阶段（Loading）")]),a._v(" "),_("h3",{attrs:{id:"_2-1-加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-加载"}},[a._v("#")]),a._v(" 2.1 加载")]),a._v(" "),_("p",[_("strong",[a._v("加载的理解：")]),a._v("\n所谓加载，简而言之就是"),_("strong",[a._v("将 Java 类的字节码文件加载到机器内存中，并在内存中构建出 Java 类的原型——类模板对象")]),a._v("。所谓类模板对象，其实就是 "),_("code",[a._v("Java")]),a._v("类在 "),_("code",[a._v("JVM")]),a._v("内存中的一个快照，"),_("code",[a._v("JVM")]),a._v("将从字节码文件中解析出的"),_("strong",[a._v("常量池、类字段、类方法")]),a._v("等信息存储到模板中，这样 "),_("code",[a._v("JVM")]),a._v("在运行期便能通过类模板而获取 "),_("code",[a._v("Java")]),a._v("类中的任意信息，能够对 "),_("code",[a._v("Java")]),a._v("类的成员变量进行遍历，也能进行"),_("code",[a._v("Java")]),a._v("方法的调用。\n反射机制即基于这一基础。如果 "),_("code",[a._v("JVM")]),a._v("没有将 "),_("code",[a._v("Java")]),a._v(" 类的声明信息存储起来，则 "),_("code",[a._v("JVM")]),a._v("在运行期也无法反射。\n加载阶段，简言之，查找并加载类的二进制数据，生成 Class 的实例\n在加载类时，"),_("code",[a._v("Java")]),a._v("虚拟机必须完成以下3件事情：")]),a._v(" "),_("ul",[_("li",[a._v("通过类的全名，获取类的二进制数据流")]),a._v(" "),_("li",[a._v("解析类的二进制数据流为方法区内的数据结构("),_("code",[a._v("Java")]),a._v("类模型)")]),a._v(" "),_("li",[a._v("创建 "),_("code",[a._v("java.lang.Class")]),a._v(" 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口")])]),a._v(" "),_("h3",{attrs:{id:"_2-2-二进制流的获取方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-二进制流的获取方式"}},[a._v("#")]),a._v(" 2.2 二进制流的获取方式")]),a._v(" "),_("p",[a._v("对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。(只要所读取的字节码符合 "),_("code",[a._v("JVM")]),a._v("规范即可)")]),a._v(" "),_("ul",[_("li",[a._v("虚拟机可能通过文件系统读入一个 "),_("code",[a._v("class")]),a._v("后缀的文件(最常见)")]),a._v(" "),_("li",[a._v("读入 jar、zip 等归档数据包，提取类文件")]),a._v(" "),_("li",[a._v("事先存放在数据库中的类的二进制数据")]),a._v(" "),_("li",[a._v("使用类似于 HTTP 之类的协议通过网络进行加载")]),a._v(" "),_("li",[a._v("在运行时生成一段 Class 的二进制信息等")])]),a._v(" "),_("p",[a._v("在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 "),_("code",[a._v("java.lang.Class")]),a._v(" 的实例")]),a._v(" "),_("p",[a._v("如果输入数据不是 "),_("code",[a._v("ClassFile")]),a._v("的结构，则会抛出 "),_("code",[a._v("ClassFormatError")])]),a._v(" "),_("h3",{attrs:{id:"_2-3-类模型与class实例的位置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-类模型与class实例的位置"}},[a._v("#")]),a._v(" 2.3 类模型与Class实例的位置")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("类模型的位置\n加载的类在 "),_("code",[a._v("JVM")]),a._v("中创建相应的类结构，类结构会存储在方法区("),_("code",[a._v("JDK 1.8")]),a._v("之前：永久代；"),_("code",[a._v("JDK 1.8")]),a._v("之后："),_("strong",[a._v("元空间")]),a._v(")")])]),a._v(" "),_("li",[_("p",[_("code",[a._v("Class")]),a._v("实例的位置\n"),_("strong",[a._v("类将 "),_("code",[a._v(".class")]),a._v("文件加载至元空间后，会在堆中创建一个 "),_("code",[a._v("java.lang.Class")]),a._v(" 对象，用来封装类位于方法区内的数据结构，该 "),_("code",[a._v("Class")]),a._v("对象是在加载类的过程中创建的，每个类都对应有一个 "),_("code",[a._v("Class")]),a._v("类型的对象")])])]),a._v(" "),_("li",[_("p",[a._v("图示")]),a._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"image-20210330105824662",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/5b516837d8464ec88493385e601fac6e.png"}},[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/5b516837d8464ec88493385e601fac6e.png",alt:"image-20210330105824662"}})])]),a._v(" "),_("p",[a._v("​\t外部可以通过访问代表 "),_("code",[a._v("Order")]),a._v("类的 "),_("code",[a._v("Class")]),a._v(" 对象来获取 "),_("code",[a._v("Order")]),a._v("的类数据结构")]),a._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[a._v("说明\n"),_("code",[a._v("Class")]),a._v("类的构造方法是私有的，只有 "),_("code",[a._v("JVM")]),a._v("能够创建")])]),a._v(" "),_("p",[_("code",[a._v("java.lang.Class")]),a._v(" 实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过 "),_("code",[a._v("Class")]),a._v("类提供的接口，可以获得目标类所关联的 "),_("code",[a._v(".class")]),a._v("文件中具体的数据结构：方法、字段等信息")])])]),a._v(" "),_("h3",{attrs:{id:"_2-4-数组类的加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-数组类的加载"}},[a._v("#")]),a._v(" 2.4 数组类的加载")]),a._v(" "),_("p",[a._v("创建数组类的情况稍微有些特殊，因为"),_("strong",[a._v("数组类本身并不是由类加载器负责创建")]),a._v("，而是"),_("strong",[a._v("由 JVM 在运行时根据需要而直接创建的")]),a._v("，但"),_("strong",[a._v("数组的元素类型仍然需要依靠类加载器去创建")]),a._v("。创建数组类(下述简称 A)的过程：")]),a._v(" "),_("ol",[_("li",[a._v("如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型")]),a._v(" "),_("li",[a._v("JVM 使用指定的元素类型和数组维度来创建新的数组类")])]),a._v(" "),_("p",[a._v("如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 "),_("code",[a._v("public")])]),a._v(" "),_("h2",{attrs:{id:"三、链接阶段-linking"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、链接阶段-linking"}},[a._v("#")]),a._v(" 三、链接阶段(Linking)")]),a._v(" "),_("h3",{attrs:{id:"_3-1-验证-verification"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-验证-verification"}},[a._v("#")]),a._v(" 3.1 验证(Verification)")]),a._v(" "),_("p",[a._v("当类加载到系统后，就开始链接操作，验证是链接操作的第一步\n"),_("strong",[a._v("它的目的是保证加载的字节码是合法、合理并符合规范的")]),a._v("\n验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 "),_("code",[a._v("Java")]),a._v("虚拟机需要做以下检查，如图所示")]),a._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"image-20210330111426037",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/1c37c7e3efd7432187eaff508f40b149.png"}},[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/1c37c7e3efd7432187eaff508f40b149.png",alt:"image-20210330111426037"}})])]),a._v(" "),_("p",[a._v("整体说明：\n验证的内容涵盖了类数据信息的"),_("strong",[a._v("格式验证、语义检查、字节码验证，以及符号引用验证")]),a._v("等\n其中"),_("strong",[a._v("格式验证会和加载阶段一起执行")]),a._v("。"),_("strong",[a._v("验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中，格式验证之外的验证操作将会在方法区中进行")])]),a._v(" "),_("p",[a._v("链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查")]),a._v(" "),_("p",[a._v("具体说明：")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("格式验证：是否以魔数 "),_("code",[a._v("0xCAFEBABE")]),a._v(" 开头，主版本和副版本号是否在当前 "),_("code",[a._v("Java")]),a._v("虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等")])]),a._v(" "),_("li",[_("p",[_("code",[a._v("Java")]),a._v(" 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：")]),a._v(" "),_("ul",[_("li",[a._v("是否所有的类都有父类的存在(在 "),_("code",[a._v("Java")]),a._v(" 里，除了 "),_("code",[a._v("Object")]),a._v(" 外，其他类都应该有父类)")]),a._v(" "),_("li",[a._v("是否一些被定义为 "),_("code",[a._v("final")]),a._v(" 的方法或者类被重写或继承了")]),a._v(" "),_("li",[a._v("非抽象类是否实现了所有抽象方法或者接口方法")]),a._v(" "),_("li",[a._v("是否存在不兼容的方法(比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；"),_("code",[a._v("absract")]),a._v(" 情况下的方法，就不能是"),_("code",[a._v("final")]),a._v(" 的了)")])])]),a._v(" "),_("li",[_("p",[_("code",[a._v("Java")]),a._v(" 虚拟机还会进行字节码验证，字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：")]),a._v(" "),_("ul",[_("li",[a._v("在字节码的执行过程中，是否会跳转到一条不存在的指令")]),a._v(" "),_("li",[a._v("函数的调用是否传递了正确类型的参数")]),a._v(" "),_("li",[a._v("变量的赋值是不是给了正确的数据类型等\n栈映射帧("),_("code",[a._v("StackMapTable")]),a._v(")就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。"),_("strong",[a._v("如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类")]),a._v("。但是，"),_("strong",[a._v("如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的")])])]),a._v(" "),_("p",[a._v("在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的")])]),a._v(" "),_("li",[_("p",[a._v("校验器还将进行符号引用的验证。"),_("code",[a._v("Class")]),a._v(" 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用的类无法在系统中找到，则会抛出 "),_("code",[a._v("NoClassDefFoundError")]),a._v("，如果一个方法无法被找到，则会抛出 "),_("code",[a._v("NoSuchMethdError")]),a._v(" "),_("strong",[a._v("此阶段在解析环节才会执行")])])])]),a._v(" "),_("h3",{attrs:{id:"_3-2-准备-praparation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-准备-praparation"}},[a._v("#")]),a._v(" 3.2 准备(Praparation)")]),a._v(" "),_("p",[a._v("准备阶段("),_("code",[a._v("Preparation")]),a._v(")，简言之，"),_("strong",[a._v("为类的静态变量分配内存，并将其初始化为默认值")]),a._v("\n当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。\n"),_("code",[a._v("Java")]),a._v(" 虚拟机为各类型变量默认的初始值如表所示：")]),a._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"image-20210330124353669",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/3e0c9be6a2d84a3e8377154ece8f443d.png"}},[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/3e0c9be6a2d84a3e8377154ece8f443d.png",alt:"image-20210330124353669"}})])]),a._v(" "),_("p",[a._v("注意："),_("code",[a._v("Java")]),a._v(" 并不支持 "),_("code",[a._v("boolean")]),a._v(" 类型，对于 "),_("code",[a._v("boolean")]),a._v(" 类型，内部实现是 "),_("code",[a._v("int")]),a._v("，由于 "),_("code",[a._v("int")]),a._v(" 的默认值是 0，故对应的，"),_("code",[a._v("boolean")]),a._v(" 的默认值就是 "),_("code",[a._v("false")])]),a._v(" "),_("p",[a._v("注意：")]),a._v(" "),_("ul",[_("li",[_("strong",[a._v("这里不包含基本数据类型的字段用 "),_("code",[a._v("static final")]),a._v(" 修饰的情况，因为 "),_("code",[a._v("final")]),a._v(" 在编译的时候就会分配了，准备阶段会显式赋值")])]),a._v(" "),_("li",[a._v("注意这里不会为实例变量分配初始化，"),_("strong",[a._v("类变量会分配在方法区中")]),a._v("，而"),_("strong",[a._v("实例变量是会随着对象一起分配到 "),_("code",[a._v("Java")]),a._v("堆中")])]),a._v(" "),_("li",[a._v("在这个阶段不会像初始化阶段中那样会有初始化或者代码被执行")])]),a._v(" "),_("h3",{attrs:{id:"_3-3-解析-resolution"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-解析-resolution"}},[a._v("#")]),a._v(" 3.3 解析(Resolution)")]),a._v(" "),_("p",[a._v("解析阶段(Resolution)，简言之，"),_("strong",[a._v("将类、接口、字段和方法的符号引用转为直接引用。")])]),a._v(" "),_("ol",[_("li",[_("p",[a._v("具体描述\n"),_("strong",[a._v("符号引用就是一些字面量的引用")]),a._v("，和虚拟机的内部数据结构和内存分布无关。比较容理解的就是在 "),_("code",[a._v("Class")]),a._v("类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当 "),_("code",[a._v("println()")]),a._v(" 方法被调用时，系统需要明确知道该方法的位置")]),a._v(" "),_("p",[a._v("举例:输出操作"),_("code",[a._v("System.out.println()")]),a._v("对应的字节码:\n"),_("code",[a._v("invokevirtual #24 <java/io/PrintStream.println>")])]),a._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"image-20210330124733794",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/55161a322d6f4d1e82b58bce46c77dcb.png"}},[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/55161a322d6f4d1e82b58bce46c77dcb.png",alt:"image-20210330124733794"}})])]),a._v(" "),_("p",[a._v("以方法为例，"),_("code",[a._v("Java")]),a._v(" 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。"),_("strong",[a._v("通过解析操作，符号引用就可以转变为目标方法在类的方法表中的具体位置")]),a._v("，从而使得方法被成功调用")])]),a._v(" "),_("li",[_("p",[a._v("小结\n所谓解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，"),_("strong",[a._v("如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。")]),a._v(" "),_("strong",[a._v("但只存在符号引用，不能确定系统中一定存在该结构")])]),a._v(" "),_("p",[a._v("不过 Java 虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在 "),_("code",[a._v("HotSpot VM")]),a._v("中，"),_("strong",[a._v("加载、验证、准备和初始化会按照顺序有条不紊地执行")]),a._v("，但"),_("strong",[a._v("链接阶段中的解析操作往往会伴随着 JVM 在执行完初始化之后再执行。")])])]),a._v(" "),_("li",[_("p",[a._v("字符串的复习\n最后，再来看一下 "),_("code",[a._v("CONSTANT_String")]),a._v("的解析。由于字符串在程序开发中有着重要的作用，因此，读者有必要了解一下 "),_("code",[a._v("String")]),a._v("在 "),_("code",[a._v("Java")]),a._v("虚拟机中的处理。当在 "),_("code",[a._v("Java")]),a._v("代码中直接使用字符串常量时，就会在类中出现 "),_("code",[a._v("CONSTANT_String")]),a._v("，它表示字符串常量，并且会引用一个 "),_("code",[a._v("CONSTANT_UTF8")]),a._v(" 的常量项。在 "),_("code",[a._v("Java")]),a._v("虚拟机内部运行中的常量池，会维护一张字符串拘留表("),_("code",[a._v("intern")]),a._v(")，它会保存所有出现过的字符串常量，并且没有重复项。只要以 "),_("code",[a._v("CONSTANT_String")]),a._v("形式出现的字符串也都会在这张表中。使用 "),_("code",[a._v("String.intern()")]),a._v(" 方法可以得到一个字符串在拘留表中的引用，因为该表中没有重复项，所以任何字面相同的字符串的 "),_("code",[a._v("String.intern()")]),a._v(" 方法返回总是相等的。")])])]),a._v(" "),_("h2",{attrs:{id:"四、初始化阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、初始化阶段"}},[a._v("#")]),a._v(" 四、初始化阶段")]),a._v(" "),_("p",[a._v("在初始化阶段，会"),_("strong",[a._v("为类的静态变量赋予正确的初始值")])]),a._v(" "),_("ol",[_("li",[_("p",[a._v("具体描述\n类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行 "),_("code",[a._v("Java")]),a._v("字节码。(即：到了初始化阶段，才真正开始执行类中定义的 "),_("code",[a._v("Java")]),a._v("程序代码)")]),a._v(" "),_("p",[_("strong",[a._v("初始化阶段的重要工作是执行类的初始化方法："),_("code",[a._v("<clinit>()")]),a._v(" 方法")]),a._v("\n该方法仅能由 "),_("code",[a._v("Java")]),a._v(" 编译器生成并由 "),_("code",[a._v("JVM")]),a._v(" 调用，程序开发者无法自定义一个同名的方法，更无法直接在 "),_("code",[a._v("Java")]),a._v(" 程序中调用该方法，虽然该方法也是由字节码指令所组成\n它是类"),_("strong",[a._v("静态成员的赋值语句")]),a._v("以及 "),_("strong",[_("code",[a._v("static")]),a._v(" 语句块")]),a._v("合并产生的")])]),a._v(" "),_("li",[_("p",[a._v("说明\n"),_("strong",[a._v("在加载一个类之前，虚拟机总是会试图加载该类的父类")]),a._v("，因此父类的 总是在子类 之前被调用，也就是说，"),_("strong",[a._v("父类的 static 块优先级高于子类")])])])]),a._v(" "),_("p",[_("code",[a._v("Java")]),a._v("编译器并不会为所有的类都产生"),_("code",[a._v("<clinit>()")]),a._v(" 初始化方法。")]),a._v(" "),_("p",[a._v("以下情况，在类被编译为字节码后，"),_("strong",[a._v("字节码文件中将不会包含 "),_("code",[a._v("<clinit>()")]),a._v(" 方法")]),a._v("：")]),a._v(" "),_("ul",[_("li",[a._v("一个类中并没有声明任何的类变量，也没有静态代码块时")]),a._v(" "),_("li",[a._v("一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时")]),a._v(" "),_("li",[a._v("一个类中包含 static final 修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式")])]),a._v(" "),_("h3",{attrs:{id:"_4-1-static-与-final-的搭配问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-static-与-final-的搭配问题"}},[a._v("#")]),a._v(" 4.1 static 与 final 的搭配问题")]),a._v(" "),_("ol",[_("li",[a._v("使用 "),_("code",[a._v("static")]),a._v(" 与 "),_("code",[a._v("final")]),a._v(" 修饰的字段的显示赋值操作，在链接阶段的准备阶段进行\n"),_("ol",[_("li",[a._v("对于基本数据类型、使用字面量进行赋值的 "),_("code",[a._v("String")]),a._v("类型，如果被 "),_("code",[a._v("static")]),a._v(" 和 "),_("code",[a._v("final")]),a._v("修饰过，并且在初始化时不涉及方法或构造器的调用，则其显示赋值在链接阶段的准备阶段进行")]),a._v(" "),_("li",[a._v("其余赋值操作，均在初始化阶段的 "),_("code",[a._v("<clinit>()")]),a._v(" 进行")])])])]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[a._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("InitializationTest2")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//在初始化阶段<clinit>()中赋值")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//在链接阶段的准备环节赋值")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" INT_CONSTANT "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//在初始化阶段<clinit>()中赋值（涉及到方法的调用）")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),a._v(" INTEGER_CONSTANT1 "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("valueOf")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//在初始化阶段<clinit>()中赋值")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),a._v(" INTEGER_CONSTANT2 "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("valueOf")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("1000")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//在链接阶段的准备环节赋值（字面量赋值，不涉及方法调用）")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" s0 "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[a._v('"helloworld0"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//在初始化阶段<clinit>()中赋值（需要调用构造器）")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" s1 "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token string"}},[a._v('"helloworld1"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//在初始化阶段<clinit>()中赋值")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" s2 "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[a._v('"helloworld2"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//在初始化阶段<clinit>()中赋值")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" NUM1 "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Random")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("nextInt")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),_("h3",{attrs:{id:"_4-2-clinit-方法的线程安全问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-clinit-方法的线程安全问题"}},[a._v("#")]),a._v(" 4.2 clinit 方法的线程安全问题")]),a._v(" "),_("p",[a._v("对于 "),_("code",[a._v("<clinit>()")]),a._v(" 方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性")]),a._v(" "),_("p",[a._v("虚拟机会保证一个类的"),_("code",[a._v("<clinit>()")]),a._v("方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的"),_("code",[a._v("<clinit>()")]),a._v("方法，其他线程都需要阻塞等待，直到活动线程执行"),_("code",[a._v("<clinit>()")]),a._v("方法完毕")]),a._v(" "),_("p",[a._v("正是因为函数"),_("code",[a._v("<clinit>()")]),a._v("带锁线程安全的，因此，如果一个在类的 "),_("code",[a._v("<clinit>()")]),a._v("方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息")]),a._v(" "),_("p",[a._v("如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行"),_("code",[a._v("<clinit>()")]),a._v("方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息")]),a._v(" "),_("h3",{attrs:{id:"_4-3-主动使用与被动使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-主动使用与被动使用"}},[a._v("#")]),a._v(" 4.3 主动使用与被动使用")]),a._v(" "),_("p",[_("code",[a._v("Java")]),a._v(" 程序对类的使用分为两种："),_("strong",[a._v("主动使用")]),a._v(" 和 "),_("strong",[a._v("被动使用")])]),a._v(" "),_("h4",{attrs:{id:"_4-3-1-主动使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-主动使用"}},[a._v("#")]),a._v(" 4.3.1 "),_("strong",[a._v("主动使用")])]),a._v(" "),_("p",[_("code",[a._v("Class")]),a._v(" 只有在必须要首次使用的时候才会被装载，"),_("code",[a._v("Java")]),a._v(" 虚拟机不会无条件地装载 "),_("code",[a._v("Class")]),a._v(" 类。"),_("code",[a._v("Java")]),a._v(' 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的"使用"，是指主动使用，主动使用只有下列几种情况：(即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成)')]),a._v(" "),_("ul",[_("li",[a._v("当创建一个类的实例时，比如使用 "),_("strong",[_("code",[a._v("new")]),a._v("关键字")]),a._v("，或者通过"),_("strong",[a._v("反射、克隆、反序列化")])]),a._v(" "),_("li",[a._v("当"),_("strong",[a._v("调用类的静态方法")]),a._v("时，即当使用了字节码 "),_("code",[a._v("invokestatic")]),a._v("指令")]),a._v(" "),_("li",[a._v("当"),_("strong",[a._v("使用类、接口的静态字段时")]),a._v("(final 修饰特殊考虑)，比如，使用 "),_("code",[a._v("getstatic")]),a._v(" 或者 "),_("code",[a._v("putstatic")]),a._v(" 指令。(对应访问变量、赋值变量操作)")]),a._v(" "),_("li",[a._v("当使用 "),_("code",[a._v("java.lang.reflect")]),a._v(" 包中的方法"),_("strong",[a._v("反射类的方法")]),a._v("时。比如："),_("code",[a._v('Class.forname("com.atguigu.java.Test")')])]),a._v(" "),_("li",[a._v("当"),_("strong",[a._v("初始化子类时")]),a._v("，如果发现其分类还没有进行过初始化，则"),_("strong",[a._v("需要先触发其父类的初始化")])]),a._v(" "),_("li",[a._v("如果一个接口定义了 "),_("code",[a._v("default")]),a._v(" 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化")]),a._v(" "),_("li",[a._v("当虚拟机启动时，用户需要指定一个要执行的主类(包含 "),_("code",[a._v("main()")]),a._v(" 方法的那个类)，虚拟机会先初始化这个主类")]),a._v(" "),_("li",[a._v("当初次调用 "),_("code",[a._v("MethodHandle")]),a._v("实例时，初始化该 "),_("code",[a._v("MethodHandle")]),a._v("指向的方法所在的类。(涉及解析 "),_("code",[a._v("REF_getStatic、REF_putStatic、REF_invokeStatic")]),a._v(" 方法句柄对应的类)（8了解，掌握以上7点即可）")])]),a._v(" "),_("p",[a._v("针对5，补充说明：\n当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口\n"),_("strong",[a._v("在初始化一个类时，并不会先初始化它所实现的接口")]),a._v(" "),_("strong",[a._v("在初始化一个接口时，并不会先初始化它的父接口")]),a._v("\n因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，"),_("strong",[a._v("只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化")])]),a._v(" "),_("p",[a._v("针对7，说明：\n"),_("code",[a._v("JVM")]),a._v("启动的时候通过"),_("strong",[a._v("引导类加载器加载一个初始类")]),a._v("。这个类在调用 "),_("code",[a._v("public static void main(String[])")]),a._v(" 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载、链接和初始化")]),a._v(" "),_("h4",{attrs:{id:"_4-3-2-被动使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-被动使用"}},[a._v("#")]),a._v(" 4.3.2 "),_("strong",[a._v("被动使用")])]),a._v(" "),_("p",[a._v("除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化\n也就是说："),_("strong",[a._v("并不是在代码中出现的类，就一定会被加载或者初始化")]),a._v("。如果不符合主动使用的条件，类就不会初始化")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("当访问一个静态字段时，只有真正声明这个字段的类才会被初始化")]),a._v(" "),_("p",[_("strong",[a._v("当通过子类引用父类的静态变量，不会导致子类初始化")])])]),a._v(" "),_("li",[_("p",[a._v("通过数组定义类引用，不会触发此类的初始化")]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Parent")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" parents "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Parent")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//不会触发Parent类的初始化，但会加载Parent类")]),a._v("\n")])])]),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[a._v("parents"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Parent")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//给数组元素赋值时，才开始加载Parent类")]),a._v("\n")])])])]),a._v(" "),_("li",[_("p",[_("strong",[a._v("引用变量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了")])])]),a._v(" "),_("li",[_("p",[_("strong",[a._v("调用 "),_("code",[a._v("ClassLoader")]),a._v("类的 "),_("code",[a._v("loadClass()")]),a._v(" 方法加载一个类，并不是对类的主动使用，不会导致类的初始化")])])])]),a._v(" "),_("h2",{attrs:{id:"五、类的使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、类的使用"}},[a._v("#")]),a._v(" 五、类的使用")]),a._v(" "),_("p",[a._v("任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。\n开发人员可以在程序中访问和调用它的静态类成员信息（比如:静态字段、静态方法)），或者使用new关键字为其创建对象实例。")]),a._v(" "),_("h2",{attrs:{id:"六、类的卸载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、类的卸载"}},[a._v("#")]),a._v(" 六、类的卸载")]),a._v(" "),_("h3",{attrs:{id:"_6-1-类、类的加载器、类的实例之间的引用关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-类、类的加载器、类的实例之间的引用关系"}},[a._v("#")]),a._v(" 6.1 类、类的加载器、类的实例之间的引用关系")]),a._v(" "),_("p",[a._v("在类加载器的内部实现中，用一个 "),_("code",[a._v("Java")]),a._v("集合来存放所加载类的引用。另一方面，一个 "),_("code",[a._v("Class")]),a._v("对象总是会引用它的类加载器，调用 "),_("code",[a._v("Class")]),a._v(" 对象的 "),_("code",[a._v("getClassLoader()")]),a._v(" 方法，就能获得它的类加载器。由此可见，"),_("strong",[a._v("代表某个类的 Class 实例与其类的加载器之间为双向关联关系")])]),a._v(" "),_("p",[a._v("**一个类的实例总是引用代表这个类的 "),_("code",[a._v("Class")]),a._v(" 对象。**在 "),_("code",[a._v("Object")]),a._v(" 类中定义了 "),_("code",[a._v("getClass()")]),a._v(" 方法，这个方法返回代表对象所属类的 "),_("code",[a._v("Class")]),a._v(" 对象的引用。此外，所有的 "),_("code",[a._v("Java")]),a._v(" 类都有一个静态属性 "),_("code",[a._v("Class")]),a._v("，它引用代表这个类的 "),_("code",[a._v("Class")]),a._v(" 对象")]),a._v(" "),_("h3",{attrs:{id:"_6-2-类的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-类的生命周期"}},[a._v("#")]),a._v(" 6.2 类的生命周期")]),a._v(" "),_("p",[a._v("当 "),_("code",[a._v("Sample")]),a._v("类被"),_("strong",[a._v("加载、链接和初始化后，它的生命周期就开始了")]),a._v("。当代表 "),_("code",[a._v("Sample")]),a._v(" 类的 "),_("code",[a._v("Class")]),a._v(" 对象不再被引用，即不可触及时，"),_("code",[a._v("Class")]),a._v(" 对象就会结束生命周期，"),_("code",[a._v("Sample")]),a._v(" 类在方法区内的数据也会被卸载，从而结束 "),_("code",[a._v("Sample")]),a._v(" 类的生命周期")]),a._v(" "),_("p",[_("strong",[a._v("一个类何时结束生命周期，取决于代表它的 "),_("code",[a._v("Class")]),a._v(" 对象何时结束生命周期")])]),a._v(" "),_("h3",{attrs:{id:"_6-3-具体例子"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-具体例子"}},[a._v("#")]),a._v(" 6.3 具体例子")]),a._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"image-20210330144431947",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/c438663b738f4df981f62666f836d2d9.png"}},[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-30/c438663b738f4df981f62666f836d2d9.png",alt:"image-20210330144431947"}})])]),a._v(" "),_("p",[_("code",[a._v("Loader1")]),a._v("变量和 "),_("code",[a._v("obj")]),a._v(" 变量间接应用代表 "),_("code",[a._v("Sample")]),a._v(" 类的 "),_("code",[a._v("Class")]),a._v(" 对象，而 "),_("code",[a._v("objClass")]),a._v(" 变量则直接引用它")]),a._v(" "),_("p",[a._v("如果程序运行过程中，将上图左侧三个引用变量都置为 "),_("code",[a._v("null")]),a._v("，此时 "),_("code",[a._v("Sample")]),a._v(" 对象结束生命周期，"),_("code",[a._v("MyClassLoader")]),a._v("对象结束生命周期，代表 "),_("code",[a._v("Sample")]),a._v("类的 "),_("code",[a._v("Class")]),a._v("对象也结束生命周期，"),_("code",[a._v("Sample")]),a._v("类在方法区内的二进制数据被卸载")]),a._v(" "),_("p",[a._v("当再次有需要时，会检查 "),_("code",[a._v("Sample")]),a._v(" 类的 "),_("code",[a._v("Class")]),a._v("对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 "),_("code",[a._v("Sample")]),a._v("类会被重新加载，在 "),_("code",[a._v("Java")]),a._v("虚拟机的堆区会生成一个新的代表"),_("code",[a._v("Sample")]),a._v("类的 "),_("code",[a._v("Class")]),a._v("实例(可以通过哈希码查看是否是同一个实例)")]),a._v(" "),_("h3",{attrs:{id:"_6-4-类的卸载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-类的卸载"}},[a._v("#")]),a._v(" 6.4 类的卸载")]),a._v(" "),_("ol",[_("li",[_("strong",[a._v("启动类加载器")]),a._v("加载的类型在整个运行期间是"),_("strong",[a._v("不可能被卸载")]),a._v("的("),_("code",[a._v("JVM")]),a._v("和 "),_("code",[a._v("JSL")]),a._v("规范)")]),a._v(" "),_("li",[a._v("被"),_("strong",[a._v("系统类加载器和扩展类加载器")]),a._v("加载的类型在运行期间"),_("strong",[a._v("不太可能被卸载")]),a._v("，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 "),_("code",[a._v("unreachable")]),a._v("的可能性极小")]),a._v(" "),_("li",[a._v("被开发者"),_("strong",[a._v("自定义的类加载器")]),a._v("实例加载的类型只有在"),_("strong",[a._v("很简单的上下文环境中才能被卸载")]),a._v("，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景(比如：很多时候用户在开发自定义类的加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)")]),a._v(" "),_("li",[a._v("综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该以虚拟机的类型卸载为前提，去实现系统中的特定功能。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);