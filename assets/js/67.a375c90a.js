(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{465:function(_,v,e){"use strict";e.r(v);var t=e(52),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"mysql索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引"}},[_._v("#")]),_._v(" MySQL索引")]),_._v(" "),e("p",[_._v("常见问题与解决方案")]),_._v(" "),e("ol",[e("li",[_._v("数据过多：分库分表")]),_._v(" "),e("li",[_._v("多表关联、多个join：SQL优化")]),_._v(" "),e("li",[_._v("使用索引")]),_._v(" "),e("li",[_._v("服务器调优与参数设置：调整my.cnf配置")])]),_._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20200816192734706",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-16/ec99092ab7724b5b8366e47edeb24686.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-16/ec99092ab7724b5b8366e47edeb24686.png",alt:"image-20200816192734706"}})])]),_._v(" "),e("h2",{attrs:{id:"一、索引简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、索引简介"}},[_._v("#")]),_._v(" 一、索引简介")]),_._v(" "),e("h3",{attrs:{id:"_1-1-简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-简介"}},[_._v("#")]),_._v(" 1.1 简介")]),_._v(" "),e("p",[_._v("索引（Index）是帮助MySQL高效获取数据的数据结构。索引本质就是一种数据结构。其目的是提高查询效率。")]),_._v(" "),e("p",[_._v("在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，\n这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：")]),_._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20200816193200096",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-16/b5976712d07347c2813209843c924694.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-16/b5976712d07347c2813209843c924694.png",alt:"image-20200816193200096"}})])]),_._v(" "),e("p",[_._v("​\t\t\t\t\t\t\t左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址\n为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。")]),_._v(" "),e("p",[_._v("结论：数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。")]),_._v(" "),e("h3",{attrs:{id:"_1-2-优势与劣势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-优势与劣势"}},[_._v("#")]),_._v(" 1.2 优势与劣势")]),_._v(" "),e("p",[_._v("优势：")]),_._v(" "),e("ol",[e("li",[_._v("索引可以提高数据检索的效率，降低数据库的IO成本")]),_._v(" "),e("li",[_._v("通过索引对数据进行排序，能降低数据排序的成本，降低CPU消耗")])]),_._v(" "),e("p",[_._v("劣势：")]),_._v(" "),e("ol",[e("li",[_._v("索引会降低更新表的速度，对表进行增删改的时候，都可能需要变动索引。")]),_._v(" "),e("li",[_._v("索引本身也会占用存储空间")])]),_._v(" "),e("h3",{attrs:{id:"_1-3-mysql索引结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-mysql索引结构"}},[_._v("#")]),_._v(" 1.3 MySQL索引结构")]),_._v(" "),e("p",[_._v("BTree索引：")]),_._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20200816194133570",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-16/d7402dd2883e4310806397d64d6cc5b1.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-16/d7402dd2883e4310806397d64d6cc5b1.png",alt:"image-20200816194133570"}})])]),_._v(" "),e("p",[_._v("【初始化介绍】\n一颗b树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），\n如磁盘块1包含数据项17和35，包含指针P1、P2、P3，\nP1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。\n真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。\n==非叶子节点不存储真实的数据，只存储指引搜索方向的数据项==，如17、35并不真实存在于数据表中。")]),_._v(" "),e("p",[_._v("【查找过程】\n如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。")]),_._v(" "),e("p",[_._v("真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。")]),_._v(" "),e("p",[_._v("B+Tree：")]),_._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20200816204431787",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-16/e8916bfce6f34f1e84c6a1309818c154.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-16/e8916bfce6f34f1e84c6a1309818c154.png",alt:"image-20200816204431787"}})])]),_._v(" "),e("p",[_._v("B+树的特性：")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；")])]),_._v(" "),e("li",[e("p",[_._v("不可能在非叶子结点命中；")])]),_._v(" "),e("li",[e("p",[_._v("非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；")])])]),_._v(" "),e("h3",{attrs:{id:"_1-4-mysql索引分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-mysql索引分类"}},[_._v("#")]),_._v(" 1.4 MySQL索引分类")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("单值索引")]),_._v(" "),e("p",[_._v("即一个索引只包含单个列，一个表可以有多个单值索引。")]),_._v(" "),e("p",[_._v("单独建单值索引：\nCREATE  INDEX idx_customer_name ON customer(customer_name);")]),_._v(" "),e("p",[_._v("删除索引：\nDROP INDEX idx_customer_name  on customer;")])]),_._v(" "),e("li",[e("p",[_._v("唯一索引")]),_._v(" "),e("p",[_._v("索引列的值必须唯一，但允许有空值")]),_._v(" "),e("p",[_._v("单独建唯一索引：\nCREATE UNIQUE INDEX idx_customer_no ON customer(customer_no);")]),_._v(" "),e("p",[_._v("删除索引：\nDROP INDEX idx_customer_no on customer ;")])]),_._v(" "),e("li",[e("p",[_._v("主键索引")]),_._v(" "),e("p",[_._v("设定为主键后数据库会自动建立索引，innodb为聚簇索引")]),_._v(" "),e("p",[_._v("单独建主键索引：\nALTER TABLE customer add PRIMARY KEY customer(customer_no);"),e("br"),_._v("\n删除建主键索引：\nALTER TABLE customer drop PRIMARY KEY ;")])]),_._v(" "),e("li",[e("p",[_._v("复合索引")]),_._v(" "),e("p",[_._v("即一个索引包含多个列")]),_._v(" "),e("p",[_._v("单独建索引：\nCREATE  INDEX idx_no_name ON customer(customer_no,customer_name);")]),_._v(" "),e("p",[_._v("删除索引：\nDROP INDEX idx_no_name  on customer ;")])]),_._v(" "),e("li",[e("p",[_._v("基本语法")]),_._v(" "),e("p",[_._v("创建：")]),_._v(" "),e("p",[_._v("​\tCREATE  [UNIQUE ]  INDEX [indexName] ON table_name(column))")]),_._v(" "),e("p",[_._v("​\tAlter table table_name add XXindex (column_name)")]),_._v(" "),e("p",[_._v("删除：DROP INDEX [indexName] ON mytable;")]),_._v(" "),e("p",[_._v("查看：SHOW INDEX FROM table_name\\G")])])]),_._v(" "),e("h3",{attrs:{id:"_1-5-何时使用索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-何时使用索引"}},[_._v("#")]),_._v(" 1.5 何时使用索引")]),_._v(" "),e("ol",[e("li",[_._v("主键自动创建唯一索引")]),_._v(" "),e("li",[_._v("频繁作为查询条件的字段应该创建索引")]),_._v(" "),e("li",[_._v("查询中与其它表关联的字段，外键关系建立索引")]),_._v(" "),e("li",[_._v("单键、组合索引的选择问题，组合索引性价比更高")]),_._v(" "),e("li",[_._v("查询汇总用于排序的字段，排序字段若通过索引去访问将提高排序速度")]),_._v(" "),e("li",[_._v("查询中统计或分组的字段")])]),_._v(" "),e("h3",{attrs:{id:"_1-6-哪些情况不需要创建索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-哪些情况不需要创建索引"}},[_._v("#")]),_._v(" 1.6 哪些情况不需要创建索引")]),_._v(" "),e("ol",[e("li",[_._v("表记录太少")]),_._v(" "),e("li",[_._v("经常增删改的表或字段")]),_._v(" "),e("li",[_._v("where条件里用户到的字段")]),_._v(" "),e("li",[_._v("过滤性不好的字段")])]),_._v(" "),e("h2",{attrs:{id:"二、性能分析-explain"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、性能分析-explain"}},[_._v("#")]),_._v(" 二、性能分析（Explain）")]),_._v(" "),e("p",[_._v("使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。")]),_._v(" "),e("p",[_._v("explain关键字的使用：explain + SQL语句")]),_._v(" "),e("p",[_._v("explain的执行结果包括：")]),_._v(" "),e("ol",[e("li",[_._v("表的读取顺序")]),_._v(" "),e("li",[_._v("哪些索引可以使用")]),_._v(" "),e("li",[_._v("数据读取操作的操作类型")]),_._v(" "),e("li",[_._v("哪些索引被实际使用")]),_._v(" "),e("li",[_._v("表之间的引用")]),_._v(" "),e("li",[_._v("每张表有多少行被物理查询")])]),_._v(" "),e("h3",{attrs:{id:"_2-1-字段解释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-字段解释"}},[_._v("#")]),_._v(" 2.1 字段解释")]),_._v(" "),e("p",[_._v("explain执行结果的返回值中，包含以下字段：id、select_type、table、partitions、type、possible_keys、keys、key_len、ref、rows、filtered、Extra")]),_._v(" "),e("h4",{attrs:{id:"_2-1-1-id"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-id"}},[_._v("#")]),_._v(" 2.1.1 id")]),_._v(" "),e("p",[_._v("select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，一共有三种情况：")]),_._v(" "),e("ol",[e("li",[_._v("所有Id相同，从上至下顺序执行")]),_._v(" "),e("li",[_._v("所有Id不同，Id值越大优先级越高，越先被执行。子查询的Id号会递增")]),_._v(" "),e("li",[_._v("同时存在Id相同与不同，可以将Id相同的看成一组，从上至下顺序执行；Id不同，Id值越大，越先执行")])]),_._v(" "),e("p",[_._v("每个Id，代表了一次独立的查询，一个SQL查询的次数，越少越好。")]),_._v(" "),e("h4",{attrs:{id:"_2-1-2-select-type"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-select-type"}},[_._v("#")]),_._v(" 2.1.2 select_type")]),_._v(" "),e("p",[_._v("查询的类型，主要用于区别普通查询、联合查询、子查询等复杂的查询，包含的类型有：")]),_._v(" "),e("ol",[e("li",[_._v("SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION")]),_._v(" "),e("li",[_._v("PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为Primary")]),_._v(" "),e("li",[_._v("DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里。")]),_._v(" "),e("li",[_._v("SUBQUERY：在SELECT或WHERE列表中包含了子查询（子查询的结果为单值）")]),_._v(" "),e("li",[_._v("DEPENDENT SUBQUERY：在SELECT或WHERE列表中包含了子查询,子查询基于外层（子查询的结果为多值）")]),_._v(" "),e("li",[_._v("UNCACHEABLE SUBQUREY：无法被缓存的子查询")]),_._v(" "),e("li",[_._v("UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED")]),_._v(" "),e("li",[_._v("UNION RESULT：从UNION表获取结果的SELECT")])]),_._v(" "),e("h4",{attrs:{id:"_2-1-3-table"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-table"}},[_._v("#")]),_._v(" 2.1.3 table")]),_._v(" "),e("p",[_._v("显示当前行的数据是来自哪一张表的")]),_._v(" "),e("p",[_._v("2.1.4 partitions")]),_._v(" "),e("p",[_._v("代表分区表中的命中情况，非分区表，该项为null")]),_._v(" "),e("h4",{attrs:{id:"_2-1-5-type"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-type"}},[_._v("#")]),_._v(" 2.1.5 type")]),_._v(" "),e("p",[_._v("type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：")]),_._v(" "),e("p",[_._v("system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL")]),_._v(" "),e("p",[_._v("常见的访问类型有：system>const>eq_ref>ref>range>index>ALL")]),_._v(" "),e("p",[_._v("一般来说，得保证查询至少达到range级别，最好能达到ref。")]),_._v(" "),e("ol",[e("li",[_._v("system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计")]),_._v(" "),e("li",[_._v("const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列表中，MySQL就能将该查询转换为一个常量")]),_._v(" "),e("li",[_._v("eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描")]),_._v(" "),e("li",[_._v("ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行。然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体")]),_._v(" "),e("li",[_._v("range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的where语句中出现了between、<、>、in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。")]),_._v(" "),e("li",[_._v("index：出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组")]),_._v(" "),e("li",[_._v("all：Full Table Scan，将遍历全表以找到匹配的行")]),_._v(" "),e("li",[_._v("index_merge：在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中")]),_._v(" "),e("li",[_._v("ref_or_null：对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。")]),_._v(" "),e("li",[_._v("index_subquery：利用索引来关联子查询，不再全表扫描。")]),_._v(" "),e("li",[_._v("unique_subquery：该联接类型类似于index_subquery。 子查询中的唯一索引")])]),_._v(" "),e("h4",{attrs:{id:"_2-1-6-possible-keys"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-6-possible-keys"}},[_._v("#")]),_._v(" 2.1.6 possible_keys")]),_._v(" "),e("p",[_._v("显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。")]),_._v(" "),e("h4",{attrs:{id:"_2-1-7-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-7-key"}},[_._v("#")]),_._v(" 2.1.7 key")]),_._v(" "),e("p",[_._v("实际使用的索引。如果为NULL，则没有使用索引")]),_._v(" "),e("p",[_._v("查询中若使用了覆盖索引，则该索引和查询的select字段重叠")]),_._v(" "),e("h4",{attrs:{id:"_2-1-8-key-len"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-8-key-len"}},[_._v("#")]),_._v(" 2.1.8 key_len")]),_._v(" "),e("p",[_._v("表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。")]),_._v(" "),e("p",[_._v("计算规则\n1 、先看索引上字段的类型+长度比如 int=4 ;  varchar(20) =20 ; char(20) =20"),e("br"),_._v("\n2  、如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf-8  要乘 3,GBK要乘2，\n3 、varchar这种动态字符串要加2个字节\n4、 允许为空的字段要加1个字节")]),_._v(" "),e("p",[_._v("key_len字段能够帮你检查是否充分的利用上了索引")]),_._v(" "),e("h4",{attrs:{id:"_2-1-9-ref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-9-ref"}},[_._v("#")]),_._v(" 2.1.9 ref")]),_._v(" "),e("p",[_._v("显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值")]),_._v(" "),e("h4",{attrs:{id:"_2-1-10-rows"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-10-rows"}},[_._v("#")]),_._v(" 2.1.10 rows")]),_._v(" "),e("p",[_._v("rows列显示MySQL认为它执行查询时必须检查的行数，该值越小越好")]),_._v(" "),e("h4",{attrs:{id:"_2-1-11-filtered"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-11-filtered"}},[_._v("#")]),_._v(" 2.1.11 filtered")]),_._v(" "),e("p",[_._v("这个字段表示存储引擎返回的数据在server层过滤后，剩下满足查询的记录数量的比例，注意是百分比，不是具体记录数")]),_._v(" "),e("h4",{attrs:{id:"_2-1-12-extra"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-12-extra"}},[_._v("#")]),_._v(" 2.1.12 Extra")]),_._v(" "),e("p",[_._v("包含不适合在其他列中显示但十分重要的额外信息")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("Using filesort")]),_._v(" "),e("p",[_._v("说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”")])]),_._v(" "),e("li",[e("p",[_._v("Using temporary")]),_._v(" "),e("p",[_._v("使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。")])]),_._v(" "),e("li",[e("p",[_._v("USING index")]),_._v(" "),e("p",[_._v("表示相应的select操作中使用了覆盖索引(Covering Index)，避免了访问表的数据行，效率不错！\n如果同时出现using where，表明索引被用来执行索引键值的查找;\n如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。")]),_._v(" "),e("p",[_._v("利用索引进行了排序或分组")])]),_._v(" "),e("li",[e("p",[_._v("Using where")]),_._v(" "),e("p",[_._v("表明使用了where过滤")])]),_._v(" "),e("li",[e("p",[_._v("using join buffer")]),_._v(" "),e("p",[_._v("使用了连接缓存：")])]),_._v(" "),e("li",[e("p",[_._v("impossible where")]),_._v(" "),e("p",[_._v("where子句的值总是false，不能用来获取任何元组")])]),_._v(" "),e("li",[e("p",[_._v("select tables optimized away")]),_._v(" "),e("p",[_._v("在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。")])])]),_._v(" "),e("h2",{attrs:{id:"三、查询优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、查询优化"}},[_._v("#")]),_._v(" 三、查询优化")]),_._v(" "),e("h3",{attrs:{id:"_3-1-索引失效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-索引失效"}},[_._v("#")]),_._v(" 3.1 索引失效")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("最左前缀法则")]),_._v(" "),e("p",[_._v("如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。否则跳过后面的索引会失效。")])]),_._v(" "),e("li",[e("p",[_._v("不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描")])]),_._v(" "),e("li",[e("p",[_._v("存储引擎不能使用索引中范围条件右边的列")])]),_._v(" "),e("li",[e("p",[_._v("mysql 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描")])]),_._v(" "),e("li",[e("p",[_._v("is not null 也无法使用索引,但是is null是可以使用索引的")])]),_._v(" "),e("li",[e("p",[_._v("like以通配符开头('%abc...')mysql索引失效会变成全表扫描的操作")])]),_._v(" "),e("li",[e("p",[_._v("字符串不加单引号索引失效")])])]),_._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"image-20200818225118356",href:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-18/80f9a5520636433186bf59ba993504b8.png"}},[e("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2020-08-18/80f9a5520636433186bf59ba993504b8.png",alt:"image-20200818225118356"}})])]),_._v(" "),e("p",[_._v("建议：")]),_._v(" "),e("ol",[e("li",[_._v("对于单键索引，尽量选择针对当前query过滤性更好的索引")]),_._v(" "),e("li",[_._v("在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。")]),_._v(" "),e("li",[_._v("在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引")]),_._v(" "),e("li",[_._v("在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面")]),_._v(" "),e("li",[_._v("书写sql语句时，尽量避免造成索引失效的情况")])]),_._v(" "),e("h3",{attrs:{id:"_3-2-关联查询优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-关联查询优化"}},[_._v("#")]),_._v(" 3.2 关联查询优化")]),_._v(" "),e("ol",[e("li",[_._v("保证被驱动表的join字段已经被索引")]),_._v(" "),e("li",[_._v("left join 时，选择小表作为驱动表，大表作为被驱动表。")]),_._v(" "),e("li",[_._v("inner join 时，mysql会自己帮你把小结果集的表选为驱动表。")]),_._v(" "),e("li",[_._v("子查询尽量不要放在被驱动表，有可能使用不到索引。")]),_._v(" "),e("li",[_._v("能够直接多表关联的尽量直接关联，不用子查询。")])]),_._v(" "),e("h3",{attrs:{id:"_3-3-子查询优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-子查询优化"}},[_._v("#")]),_._v(" 3.3 子查询优化")]),_._v(" "),e("p",[_._v("尽量不要使用not in  或者 not exists，用left outer join  on  xxx is null 替代")]),_._v(" "),e("h3",{attrs:{id:"_3-4-排序分组优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-排序分组优化"}},[_._v("#")]),_._v(" 3.4 排序分组优化")]),_._v(" "),e("p",[_._v("ORDER BY子句，尽量使用Index方式排序,避免使用FileSort方式排序")]),_._v(" "),e("p",[_._v("如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序")]),_._v(" "),e("p",[_._v("双路排序：")]),_._v(" "),e("p",[_._v("MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。取一批数据，要对磁盘进行了两次扫描，众所周知，I\\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。")]),_._v(" "),e("p",[_._v("单路排序：")]),_._v(" "),e("p",[_._v("从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，\n它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，\n因为它把每一行都保存在内存中了。")]),_._v(" "),e("p",[_._v("使用单路排序的问题： 在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。")]),_._v(" "),e("p",[_._v("优化策略：")]),_._v(" "),e("ol",[e("li",[_._v("增大sort_buffer_size参数的设置")]),_._v(" "),e("li",[_._v("增大max_length_for_sort_data参数的设置")]),_._v(" "),e("li",[_._v("减少select 后面的查询的字段。")])]),_._v(" "),e("p",[_._v("提高Order By的速度")]),_._v(" "),e("ol",[e("li",[_._v("Order by时select * 是一个大忌只Query需要的字段， 这点非常重要。在这里的影响是：\n1.1 当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。\n1.2 两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些,所以要提高sort_buffer_size。")]),_._v(" "),e("li",[_._v("尝试提高 sort_buffer_size\n不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的  1M-8M之间调整")]),_._v(" "),e("li",[_._v("尝试提高 max_length_for_sort_data\n提高这个参数， 会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率. 1024-8192之间调整")])]),_._v(" "),e("p",[_._v("Group by优化：group by 使用索引的原则几乎跟order by一致 ，唯一区别是groupby 即使没有过滤条件用到索引，也可以直接使用索引。")]),_._v(" "),e("p",[_._v("覆盖索引：待查询的列字段全部都是索引列。")])])}),[],!1,null,null,null);v.default=a.exports}}]);