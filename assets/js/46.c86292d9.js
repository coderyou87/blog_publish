(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{398:function(a,t,_){"use strict";_.r(t);var v=_(42),s=Object(v.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"字节码指令集与解析举例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字节码指令集与解析举例"}},[a._v("#")]),a._v(" 字节码指令集与解析举例")]),a._v(" "),_("h2",{attrs:{id:"一、概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、概述"}},[a._v("#")]),a._v(" 一、概述")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("Java")]),a._v("字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行命令。")]),a._v(" "),_("li",[_("code",[a._v("Java")]),a._v("虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为 操作码，"),_("code",[a._v("Opcode")]),a._v("）以及跟随其后的零至多个代表此操作所需参数（称为 操作数，"),_("code",[a._v("Operands")]),a._v("）而构成，由于 "),_("code",[a._v("Java")]),a._v("虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。")]),a._v(" "),_("li",[a._v("由于限制了 "),_("code",[a._v("Java")]),a._v("虚拟机操作码的长度为一个字节（即"),_("code",[a._v("0 ~ 255")]),a._v("），这意味着指令集的操作码总数不可能超过 "),_("code",[a._v("256")]),a._v("条。")]),a._v(" "),_("li",[_("a",{attrs:{href:"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("官方文档"),_("OutboundLink")],1)]),a._v(" "),_("li",[a._v("熟悉虚拟机的指令对于动态字节码生成、反编译 "),_("code",[a._v("Class")]),a._v("文件、 "),_("code",[a._v("Class")]),a._v("文件修补都有着非常重要的价值。因此，阅读字节码作为了解 "),_("code",[a._v("Java")]),a._v("虚拟机的基础技能，需要熟练掌握常见指令。")])]),a._v(" "),_("h3",{attrs:{id:"_1-1-执行模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-执行模型"}},[a._v("#")]),a._v(" 1.1 执行模型")]),a._v(" "),_("p",[a._v("如果不考虑异常处理的话，那么 Java 虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解")]),a._v(" "),_("blockquote",[_("p",[a._v("do {\n自动计算PC寄存器的值加1;\n根据PC寄存器的指示位置，从字节码流中取出操作码;\nif(字节码存在操作数) 从字节码流中取出操作数;\n执行操作码所定义的操作;\n} while(字节码长度 > 0)；")])]),a._v(" "),_("h3",{attrs:{id:"_1-2-字节码与数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-字节码与数据类型"}},[a._v("#")]),a._v(" 1.2 字节码与数据类型")]),a._v(" "),_("p",[a._v("在 Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中，而 fload 指令加载的则是 float类型的数据。")]),a._v(" "),_("p",[a._v("对于大部分与数据类型相关的字节码指令，"),_("strong",[a._v("它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：")])]),a._v(" "),_("ul",[_("li",[a._v("i 代表对 int 类型的数据操作")]),a._v(" "),_("li",[a._v("l 代表 long")]),a._v(" "),_("li",[a._v("s 代表 short")]),a._v(" "),_("li",[a._v("b 代表 byte")]),a._v(" "),_("li",[a._v("c 代表 char")]),a._v(" "),_("li",[a._v("f 代表 float")]),a._v(" "),_("li",[a._v("d 代表 double")])]),a._v(" "),_("p",[a._v("也有一些指令的助记符中"),_("strong",[a._v("没有明确地指明操作类型的字母")]),a._v("，如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。")]),a._v(" "),_("p",[a._v("还有另一些指令，如无条件跳转指令 goto 则是"),_("strong",[a._v("与数据类型无关的。")])]),a._v(" "),_("p",[a._v("大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译器或运行期将 byte 和 short 类型的数据带符号扩展（Sign-Extend）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。")]),a._v(" "),_("p",[a._v("因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。")]),a._v(" "),_("h3",{attrs:{id:"_1-3-指令分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-指令分类"}},[a._v("#")]),a._v(" 1.3 指令分类")]),a._v(" "),_("p",[a._v("字节码指令主要分为九类：")]),a._v(" "),_("ul",[_("li",[a._v("加载与存储指令")]),a._v(" "),_("li",[a._v("算术指令")]),a._v(" "),_("li",[a._v("类型转换指令")]),a._v(" "),_("li",[a._v("对象的创建与访问指令")]),a._v(" "),_("li",[a._v("方法调用与返回指令")]),a._v(" "),_("li",[a._v("操作数栈管理指令")]),a._v(" "),_("li",[a._v("比较控制指令")]),a._v(" "),_("li",[a._v("异常处理指令")]),a._v(" "),_("li",[a._v("同步控制指令")])]),a._v(" "),_("p",[a._v("在做值相关操作时：")]),a._v(" "),_("ul",[_("li",[a._v("一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用等中取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。")]),a._v(" "),_("li",[a._v("一个指令，也可以从操作数栈中取出一到多个值（pop 多次），完成赋值、加减乘除、方法传参、系统调用等操作。")])]),a._v(" "),_("h2",{attrs:{id:"二、加载与存储指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、加载与存储指令"}},[a._v("#")]),a._v(" 二、加载与存储指令")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("作用")]),a._v(" "),_("p",[a._v("加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。\n（加载：压栈的操作；存储：存进局部变量表的操作）")])]),a._v(" "),_("li",[_("p",[a._v("常用指令")]),a._v(" "),_("ul",[_("li",[a._v("【局部变量压栈指令】将一个局部变量加载到操作数栈：xload、xload_"),_("n",[a._v("（n 为 0 到 3，其中 x 为 i、l、f、d、a）xaload（其中x为i、l、f、d、a、 b、c、s)")])],1),a._v(" "),_("li",[a._v("【常量入栈指令】将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_"),_("i",[a._v("、iconst_"),_("l",[a._v("、fconst_"),_("f",[a._v("、dconst_"),_("d")],1)],1)],1)]),a._v(" "),_("li",[a._v("【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表：xstore、xstore_"),_("n",[a._v("（其中 x 为 i、l、f、d、a，n 为 0 到 3）; xastore（其中 x 为 i、l、f、d、a、b、c、s）")])],1),a._v(" "),_("li",[a._v("扩充局部变量表的访问索引的指令：wide")])])])]),a._v(" "),_("p",[a._v("上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_"),_("n",[a._v("）。这些指令助记符实际上代表了一组指令（例如iload_"),_("n",[a._v("代表了iload_0、iload_1、iload_2和 iload_3 这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如 iload）的特殊形式，对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。")])],1)],1),a._v(" "),_("p",[a._v("比如:\niload_0:将局部变量表中索引为0位置上的数据压入操作数栈中。\niload 4:将局部变量表中索引为4位置上的数据压入操作数栈中。")]),a._v(" "),_("p",[a._v("除此之外，它们的语义与原生的通用指令完全一致（例如 iload_0 的语义与操作数为 0 时的 iload 指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，"),_("n",[a._v(" 代表非负的整数，"),_("i",[a._v(" 代表是 int 类型数据，"),_("l",[a._v(" 代表 long 类型，"),_("f",[a._v(" 代表 float 类型，"),_("d",[a._v(" 代表 double 类型。")])],1)],1)],1)])],1),a._v(" "),_("p",[a._v("操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示。")]),a._v(" "),_("h3",{attrs:{id:"_2-1-操作数栈与局部变量表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-操作数栈与局部变量表"}},[a._v("#")]),a._v(" 2.1 操作数栈与局部变量表")]),a._v(" "),_("p",[a._v("在JVM运行时数据区中，与方法调用执行相关的一个区域叫“虚拟机栈”，虚拟机栈中存储的元素被称为栈帧，每一个方法从调用到运行结束，都对应着一个栈帧从入栈到出栈的过程。")]),a._v(" "),_("p",[a._v("栈帧中存储的数据有：局部变量表、操作数栈、动态链接、方法返回地址")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-21/d1a19a3450b743428c2a7f40ab3251b2.png",alt:"image-20210321172225277"}})]),a._v(" "),_("p",[_("strong",[a._v("操作数栈（Operand Stacks）：")])]),a._v(" "),_("p",[a._v("Java 字节码是 Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。\n在解释执行过程中，每当为 Java 方法分配栈帧时，Java 虚拟机往往需要开辟一块额外的空间作为"),_("strong",[a._v("操作数栈，来存放计算的操作数以及返回结果。")]),a._v("\n具体来说便是："),_("strong",[a._v("执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。")])]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-21/e0c47859c53343b38d21cc3e14bc2efe.png",alt:"image-20210321173234053"}})]),a._v(" "),_("p",[a._v("以加法指令 iadd 为例。假设在执行该指令之前，栈顶的两个元素分别为 int 值 1 和 int 值 2，那么 iadd 指令将弹出这两个 int，并将求得的和 int 值为 3 压入栈中。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-21/75fb1ddaaa914d3b876210dea285bb0b.png",alt:"image-20210321173254969"}})]),a._v(" "),_("p",[a._v("由于 iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为 2 的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。")]),a._v(" "),_("p",[_("strong",[a._v("局部变量表（Local Variables）：")])]),a._v(" "),_("p",[a._v("Java 方法栈帧的另外一个重要组成部分则是局部变量表，"),_("strong",[a._v("字节码程序可以将计算的结果缓存在局部变量区之中。")]),a._v("\n实际上，Java 虚拟机将局部变量表"),_("strong",[a._v("当成一个数组")]),a._v("，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。\n和操作数栈一样，long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-21/fce06f9e058e4634848ed8e82b768946.png",alt:"image-20210321173456321"}})]),a._v(" "),_("p",[a._v("在栈帧中，与性箭调优关系最为密切的部分就是局部变量表。"),_("strong",[a._v("局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。")])]),a._v(" "),_("p",[a._v("在方法执行时，虚拟机使用局部变量表完成方法的传递。")]),a._v(" "),_("h3",{attrs:{id:"_2-2-局部变量压栈指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-局部变量压栈指令"}},[a._v("#")]),a._v(" 2.2 局部变量压栈指令")]),a._v(" "),_("p",[a._v("局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。")]),a._v(" "),_("p",[a._v("这类指令大体可以分为：\nxload_"),_("n",[a._v("（x 为 i、l、f、d、a，n 为 0 到 3）\nxload（x 为 i、l、f、d、a）\n说明：在这里，x 的取值表示数据类型，n 表示索引")])],1),a._v(" "),_("p",[a._v("指令 xload_n 表示将第 n 个局部变量压入操作数栈，比如 iload_1、fload_0、aload_0 等指令。其中 aload_n 表示将一个对象引用压栈。")]),a._v(" "),_("p",[a._v("指令 xload 通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了 4 个，比如指令 iload、fload 等。")]),a._v(" "),_("h3",{attrs:{id:"_2-3-常量入栈指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-常量入栈指令"}},[a._v("#")]),a._v(" 2.3 常量入栈指令")]),a._v(" "),_("p",[a._v("常量入栈指令的功能是将常量压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const 系列、push 系列和 ldc 指令。（范围依次变大）")]),a._v(" "),_("p",[a._v("**指令 const 系列：**用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有："),_("code",[a._v("iconst_<i>")]),a._v("（i 从 -1 到 5 ）、"),_("code",[a._v("lconst_<l>")]),a._v("（l 从 0 到 1）、"),_("code",[a._v("fconst_<f>")]),a._v("（ f 从 0 到 2）、"),_("code",[a._v("dconst_<d>")]),a._v("（d 从 0 到 1）、"),_("code",[a._v("aconst_null")]),a._v("\n比如：\n"),_("code",[a._v("iconst_m1")]),a._v("将 -1 压入操作数栈\n"),_("code",[a._v("iconst_x")]),a._v("（x 为 0 到 5）将 x 压入栈\n"),_("code",[a._v("lconst_0")]),a._v("、"),_("code",[a._v("lconst_1")]),a._v("分别将长整数 0 和 1 压入栈\n"),_("code",[a._v("fconst_0")]),a._v("、"),_("code",[a._v("fconst_1")]),a._v("、"),_("code",[a._v("fconst_2")]),a._v("分别将浮点数 0、1、2 压入栈\n"),_("code",[a._v("dconst_0")]),a._v("和"),_("code",[a._v("dconst_1")]),a._v(" 分别将 "),_("code",[a._v("double")]),a._v("型 0 和 1 压入栈\n"),_("code",[a._v("aconst_null")]),a._v("将 "),_("code",[a._v("null")]),a._v("压入操作数栈\n从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整型，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。")]),a._v(" "),_("p",[a._v("**指令 push 系列：**主要包括 bipush 和 "),_("code",[a._v("sipush")]),a._v("，它们的区别在于接受数据类型的不同，"),_("code",[a._v("bipush")]),a._v("接收 8 位整数作为参数，"),_("code",[a._v("sipush")]),a._v("接收 16 位整数，它们都将参数压入栈。")]),a._v(" "),_("p",[a._v("指令 "),_("code",[a._v("ldc")]),a._v("系列：如果以上指令都不能满足需求，那么可以使用万能的"),_("code",[a._v("ldc")]),a._v("指令，它可以接收一个 8 位的参数，该参数指向常量池中的 "),_("code",[a._v("int")]),a._v("、"),_("code",[a._v("float")]),a._v("或者 "),_("code",[a._v("String")]),a._v("的索引，将指定的内容压入栈。\n类似的还有"),_("code",[a._v("ldc_w")]),a._v("，它接收两个 8 位参数，能支持的索引范围大于 "),_("code",[a._v("ldc")]),a._v("\n如果要压入的元素是 "),_("code",[a._v("long")]),a._v("或者 "),_("code",[a._v("double")]),a._v("类型的，则使用"),_("code",[a._v("ldc2_w")]),a._v("指令，使用方式都是类似的。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-21/bd97a17264bf46f384fff182a2dd6687.png",alt:"image-20210321175705233"}})]),a._v(" "),_("h3",{attrs:{id:"_3-4-出栈装入局部变量表指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-出栈装入局部变量表指令"}},[a._v("#")]),a._v(" 3.4 出栈装入局部变量表指令")]),a._v(" "),_("p",[a._v("出栈并装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。")]),a._v(" "),_("p",[a._v("这类指令主要以 "),_("code",[a._v("store")]),a._v("的形式存在，比如 "),_("code",[a._v("xstore")]),a._v("（x 为 i、l、f、d、a）、"),_("code",[a._v("xstore_n")]),a._v("（x 为 i、l、f、d、a，n 为 0 至 3）。\n其中，指令"),_("code",[a._v("istore_n")]),a._v("将从操作数栈中弹出一个整数，并把它赋值给局部变量索引 n 位置。\n指令 "),_("code",[a._v("xstore")]),a._v("由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置。\n"),_("code",[a._v("xastore")]),a._v("则专门针对数组操作，以 "),_("code",[a._v("iastore")]),a._v("为例，它用于给一个 "),_("code",[a._v("int")]),a._v("数组的给定索引赋值。在 "),_("code",[a._v("iastore")]),a._v("执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，"),_("code",[a._v("iastore")]),a._v("会弹出这3个值，并将值赋给数组中指定索引的位置。")]),a._v(" "),_("p",[a._v("说明：\n一般说来，类似"),_("strong",[a._v("像 "),_("code",[a._v("store")]),a._v("这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置")]),a._v("。但是，为了尽可能压缩指令大小，使用专门的 "),_("code",[a._v("istore_1")]),a._v("指令表示将弹出的元素放置在局部变量表第 1 个位置。类似的还有 "),_("code",[a._v("istore_0、istore_2、istore_3")]),a._v("，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第 0、2、3 个位置。")]),a._v(" "),_("p",[a._v("由于局部变量表前几个位置总是非常常用，"),_("strong",[a._v("因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积")]),a._v("。如果局部变量表很大，需要存储的槽位大于 3，那么可以使用 "),_("code",[a._v("istore")]),a._v("指令，外加一个参数，用来表示需要存放的槽位位置。")]),a._v(" "),_("h2",{attrs:{id:"三、算术指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、算术指令"}},[a._v("#")]),a._v(" 三、算术指令")]),a._v(" "),_("h3",{attrs:{id:"_3-1-算术指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-算术指令"}},[a._v("#")]),a._v(" 3.1 算术指令")]),a._v(" "),_("ul",[_("li",[a._v("加法指令：iadd、ladd、fadd、dadd")]),a._v(" "),_("li",[a._v("减法指令：isub、lsub、fsub、dsub")]),a._v(" "),_("li",[a._v("乘法指令：imul、lmul、fmul、dmul")]),a._v(" "),_("li",[a._v("除法指令：idiv、ldiv、fdiv、ddiv")]),a._v(" "),_("li",[a._v("求余指令：irem、lrem、frem、drem （remainder：余数）")]),a._v(" "),_("li",[a._v("取反指令：ineg、lneg、fneg、dneg （negation：取反）")]),a._v(" "),_("li",[a._v("自增指令：iinc")])]),a._v(" "),_("p",[a._v("位运算指令：")]),a._v(" "),_("ul",[_("li",[a._v("位移指令：ishl、ishr、iushr、lshl、lshr、lushr")]),a._v(" "),_("li",[a._v("按位或指令：ior、lor")]),a._v(" "),_("li",[a._v("按位与指令：iand、land")]),a._v(" "),_("li",[a._v("按位异或指令：ixor、lxor")])]),a._v(" "),_("p",[a._v("比较指令：dcmpg、dcmlp、fcmpg、fcmpl、lcmp")]),a._v(" "),_("h3",{attrs:{id:"_3-2-比较指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-比较指令"}},[a._v("#")]),a._v(" 3.2 比较指令")]),a._v(" "),_("ul",[_("li",[a._v("比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。")]),a._v(" "),_("li",[a._v("**比较指令有：**dcmpg、dcmpl、fcmpg、fcmpl、lcmp")]),a._v(" "),_("li",[a._v("与前面讲解的指令类似，首字符 d 表示 double 类型，f 表示 float，l 表示 long")]),a._v(" "),_("li",[a._v("对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令。\n以 float 为例，有 fcmpg 和 fcmpl 两个指令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同。")]),a._v(" "),_("li",[a._v("指令 dcmpl 和 dcmpg 也是类似的，根据其命名可以推测其含义。")]),a._v(" "),_("li",[a._v("指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令。")])]),a._v(" "),_("p",[_("strong",[a._v("举例：")]),a._v("\n指令 fcmpg 和 fcmpl 都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2， 栈顶顺位第 2 位元素为 v1，若 v1 = v2，则压入 0；若 v1 > v2 则压入 1；若 v1 < v2 则压入 -1。\n两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入 1，而 fcmpl 会压入 -1。")]),a._v(" "),_("p",[a._v("数值类型的数据，才可以谈大小! (byte\\short\\char都看成int型; ong\\float\\double;)\nboolean、引用数据类型不能比较大小。")]),a._v(" "),_("h2",{attrs:{id:"四、类型转换指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、类型转换指令"}},[a._v("#")]),a._v(" 四、类型转换指令")]),a._v(" "),_("p",[a._v("类型转换指令说明：")]),a._v(" "),_("ol",[_("li",[a._v("类型转换指令可以将两种不同的数值类型进行相互转换。")]),a._v(" "),_("li",[a._v("这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。")])]),a._v(" "),_("h3",{attrs:{id:"_4-1-宽化类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-宽化类型转换"}},[a._v("#")]),a._v(" 4.1 宽化类型转换")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("转换规则\nJava 虚拟机直接支持以下数值的宽化类型转换（Widening Numeric Conversion，小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括：")]),a._v(" "),_("ul",[_("li",[a._v("从 int 类型到 long、float 或者 double 类型。对应的指令为：i2l、i2f、i2d")]),a._v(" "),_("li",[a._v("从 long 类型到 float、double 类型。对应的指令为：l2f、l2d")]),a._v(" "),_("li",[a._v("从 flaot 类型到 double 类型。对应的指令为：f2d")]),a._v(" "),_("li",[a._v("简化为：int --\x3e long --\x3e float --\x3e double")])])]),a._v(" "),_("li",[_("p",[a._v("精度损失问题\n宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的。")]),a._v(" "),_("p",[a._v("从 int、long 类型数值转换到 float，或者 long 类型数值转换到 double 时，可能会发生丢失精度 —— 可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数数值。")]),a._v(" "),_("p",[a._v("尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致 Java 虚拟机抛出运行时异常。")])]),a._v(" "),_("li",[_("p",[a._v("补充说明\n从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的。对于 byte 类型转换为 int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而 byte 转为 long 时，使用的是 i2l，可以看到在内部 byte 在这里已经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点：")]),a._v(" "),_("ul",[_("li",[a._v("一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大增，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过 256 个，为了节省指令资源，将 short 和 byte 当作 int 处理也是情理之中。")]),a._v(" "),_("li",[a._v("另一方面，由于局部变量表中的槽位固定为 32 位，无论是 byte 或者 short 存入局部变量表，都会占用 32 位空间。从这个角度来说，也没有必要特意区分这几种数据类型。")])])])]),a._v(" "),_("h3",{attrs:{id:"_4-2-窄化类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-窄化类型转换"}},[a._v("#")]),a._v(" 4.2 窄化类型转换")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("转换规则\nJava 虚拟机也直接支持以下窄化类型转换：")]),a._v(" "),_("ul",[_("li",[a._v("从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2s、i2c")]),a._v(" "),_("li",[a._v("从 long 类型到 int 类型。对应的指令有：l2i")]),a._v(" "),_("li",[a._v("从 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l")]),a._v(" "),_("li",[a._v("从 double 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f")]),a._v(" "),_("li",[a._v("从 long 类型到 byte 类型。l2i => i2b")])])]),a._v(" "),_("li",[_("p",[a._v("精度损失问题\n窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。\n尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是 Java 虚拟机规范中明确规定"),_("strong",[a._v("数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常")]),a._v("。")])]),a._v(" "),_("li",[_("p",[a._v("浮点值向整数转换规则\n当一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）的时候，将遵循以下转换规则：")]),a._v(" "),_("ul",[_("li",[a._v("如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0。")]),a._v(" "),_("li",[a._v("如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T（int 或 long）的表示范围之内，那转换结果就是 v。否则，将根据 v 的符号，转换为 T 所能表示的最大或者最小正数。（MAX_VALUE）")])])]),a._v(" "),_("li",[_("p",[a._v("double向float转换规则")]),a._v(" "),_("p",[a._v("当一个 double 类型窄化转换为 float 类型时，通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这 3 条规则判断：")]),a._v(" "),_("ul",[_("li",[a._v("如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正负零。")]),a._v(" "),_("li",[a._v("如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正负无穷大。(Infinity)")]),a._v(" "),_("li",[a._v("对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。")])])])]),a._v(" "),_("h2",{attrs:{id:"五、对象的创建与访问指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、对象的创建与访问指令"}},[a._v("#")]),a._v(" 五、对象的创建与访问指令")]),a._v(" "),_("h3",{attrs:{id:"_5-1-创建指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-创建指令"}},[a._v("#")]),a._v(" 5.1 创建指令")]),a._v(" "),_("p",[a._v("虽然类实例和数组都是对象。但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令:")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("创建类实例的指令：\n创建类实例的指令: new\n它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。")])]),a._v(" "),_("li",[_("p",[a._v("创建数组的指令：\n创建数组的指令: newarray，anewarray，multianewarray\nnewarray 创建基本类型数组\nanewarray:创建引用类型数组\nmultianewarray; 创建多维数组")])])]),a._v(" "),_("p",[a._v("上述创建指令可以用于创建对象或者数组。由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高。")]),a._v(" "),_("h3",{attrs:{id:"_5-2-字段访问指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-字段访问指令"}},[a._v("#")]),a._v(" 5.2 字段访问指令")]),a._v(" "),_("p",[a._v("对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。")]),a._v(" "),_("ul",[_("li",[a._v("访问类字段(static字段， 或者称为类变量)的指令: getstatic（把相应的字段压入到操作数栈中）、 putstatic（把操作数栈的值弹出来并做赋值）")]),a._v(" "),_("li",[a._v("访问类实例字段(非static字段， 或者称为实例变量)的指令: getfield（把相应的字段压入到操作数栈中）、 putfield（把操作数栈的值弹出来并做赋值）")])]),a._v(" "),_("h3",{attrs:{id:"_5-3-数组操作指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-数组操作指令"}},[a._v("#")]),a._v(" 5.3 数组操作指令")]),a._v(" "),_("p",[a._v("数组操作指令主要有: xastore 和xaload指令。具体为:")]),a._v(" "),_("ul",[_("li",[a._v("把一个数组元素加载到操作数栈的指令: baload、caload、 saload、iaload、laload、faload、daload、aaload")]),a._v(" "),_("li",[a._v("将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、 iastore、lastore、fastore、dastore、aastore（数组存放在堆，这些指令会修改堆里的值）")]),a._v(" "),_("li",[a._v("取数组长度的指令: arraylength，该指令弹出栈顶的数组，获取数组的长度，将长度压入栈。")])]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/c5953e431bf84b9788015371839295f3.png",alt:"image-20210328114023876"}})]),a._v(" "),_("p",[_("strong",[a._v("说明")])]),a._v(" "),_("ul",[_("li",[a._v("指令xaload表示将数组的元素压栈，比如saload、 caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中"),_("strong",[a._v("栈顶元素为数组索引i,栈顶顺位第2个元素为数组引用a")]),a._v(",该指令会弹出栈顶这两个元素，并"),_("strong",[a._v("将a[i]重新压入堆栈")]),a._v("。")]),a._v(" "),_("li",[a._v("xastore则专门针对数组操作，以iastore为例， 它用于给一个int 数组的给定索引赋值。在iastore执行前，操作数栈顶需要以此准备3个元素:"),_("strong",[a._v("值、索引、数组引用")]),a._v("，iastore 会弹出这3个值，并"),_("strong",[a._v("将值赋给数组中指定索引的位置")])])]),a._v(" "),_("h3",{attrs:{id:"_5-4-类型检查指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-类型检查指令"}},[a._v("#")]),a._v(" 5.4 类型检查指令")]),a._v(" "),_("p",[a._v("检查类实例或数组类型的指令: instanceof，checkcast")]),a._v(" "),_("ul",[_("li",[a._v("指令checkcast用于检 查类型强制转换是否可以进行。如果可以进行。那么checkcast指令不会改变操作数栈否则它会抛出ClassCastException异常。")]),a._v(" "),_("li",[a._v("指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。")])]),a._v(" "),_("h2",{attrs:{id:"六、方法调用与返回指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、方法调用与返回指令"}},[a._v("#")]),a._v(" 六、方法调用与返回指令")]),a._v(" "),_("h3",{attrs:{id:"_6-1-方法调用指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-方法调用指令"}},[a._v("#")]),a._v(" 6.1 方法调用指令")]),a._v(" "),_("p",[a._v("方法调用指令: "),_("code",[a._v("invokevirtual")]),a._v("， "),_("code",[a._v("invokeinterface")]),a._v("，"),_("code",[a._v("invokespecial")]),a._v("， "),_("code",[a._v("invokestatic")]),a._v("，"),_("code",[a._v("invokedynamic")]),a._v("\n以下5条指令用于方法调用:")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("invokevirtual")]),a._v("指令用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)，支持多态。这也是"),_("code",[a._v("Java")]),a._v("语言中最常见的方法分派方式。")]),a._v(" "),_("li",[_("code",[a._v("invokeinterface")]),a._v("指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，井找出适合的方法进行调用。")]),a._v(" "),_("li",[_("code",[a._v("invokespecial")]),a._v("指令用于调用一些需要特殊处理的实例方法， 包括"),_("strong",[a._v("实例初始化方法(构造器)、私有方法和父类方法")]),a._v("。这些方法都是"),_("strong",[a._v("静态类型绑定")]),a._v("的，不会在调用时进行动态派发。(这三个方法已经很明确不会被重写）")]),a._v(" "),_("li",[_("code",[a._v("invokestatic")]),a._v("指令用于调用命名类中的类方法("),_("code",[a._v("static")]),a._v("方法) 。这是静态绑定的。")]),a._v(" "),_("li",[_("code",[a._v("invokedynamic")]),a._v("调用动态绑定的方法，这个是"),_("code",[a._v("JDK 1.7")]),a._v("后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都在"),_("code",[a._v("java")]),a._v("虚拟机内部，而"),_("code",[a._v("invokedynamic")]),a._v("指令的分派逻辑是由用户所设定的引导方法决定的。")])]),a._v(" "),_("h3",{attrs:{id:"_6-2-方法返回指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-方法返回指令"}},[a._v("#")]),a._v(" 6.2 方法返回指令")]),a._v(" "),_("p",[a._v("方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的。\n包括"),_("code",[a._v("ireturn")]),a._v("(当返回值是boolean， byte，char，short和int 类型时使用)、"),_("code",[a._v("lreturn")]),a._v("，"),_("code",[a._v("freturn")]),a._v("，"),_("code",[a._v("dreturn")]),a._v("和"),_("code",[a._v("areturn")]),a._v("。\n另外还有一条"),_("code",[a._v("return")]),a._v("指令供声明为**"),_("code",[a._v("void")]),a._v("的方法、实例初始化方法以及类和接口的类初始化方法**使用。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/1f965218dc5242a580c5d4f5f45f1806.png",alt:"image-20210328114719427"}})]),a._v(" "),_("p",[a._v("举例:\n通过"),_("code",[a._v("ireturn")]),a._v("指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中(因为调用者非常关心函数的返回值)，所有在当前函数操作数栈中的其他元素都会被丢弃。")]),a._v(" "),_("p",[a._v("如果当前返回的是"),_("code",[a._v("synchronized")]),a._v("方法，那么还会执行一个隐含的"),_("code",[a._v("monitorexit")]),a._v("指令，退出临界区。")]),a._v(" "),_("p",[a._v("最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。")]),a._v(" "),_("h2",{attrs:{id:"七、操作数栈管理指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#七、操作数栈管理指令"}},[a._v("#")]),a._v(" 七、操作数栈管理指令")]),a._v(" "),_("p",[a._v("操作数栈管理指令：如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。")]),a._v(" "),_("p",[a._v("这类指令包括如下内容:")]),a._v(" "),_("ul",[_("li",[a._v("将一个或两个元素从栈顶弹出，并且直接废弃:"),_("code",[a._v("pop")]),a._v(", "),_("code",[a._v("pop2")]),a._v(";")]),a._v(" "),_("li",[a._v("复制栈项一个或两个数值并将复制的值或双份的复制值重新压入栈顶：dup, "),_("code",[a._v("dup2")]),a._v(","),_("code",[a._v("dup_x1")]),a._v("，"),_("code",[a._v("dup2_x1")]),a._v(", "),_("code",[a._v("dup_x2")]),a._v(", "),_("code",[a._v("dup2_x2")]),a._v(";")]),a._v(" "),_("li",[a._v("将栈最顶端的两个"),_("code",[a._v("Slot")]),a._v("数值位置交换: "),_("code",[a._v("swap")]),a._v("。 "),_("code",[a._v("Java")]),a._v(" 虚拟机没有提供交换两个64位数据类型("),_("code",[a._v("long")]),a._v("、"),_("code",[a._v("double")]),a._v(") 数值的指令。")]),a._v(" "),_("li",[a._v("指令"),_("code",[a._v("nop")]),a._v(",是一个非常特殊的指令，它的字节码为"),_("code",[a._v("0x00")]),a._v("。和汇编语言中的"),_("code",[a._v("nop")]),a._v("一样， 它表示什么都不做。这条指令一般可用于调试、占位等。")])]),a._v(" "),_("p",[a._v("这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。")]),a._v(" "),_("p",[a._v("说明:")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("不带"),_("code",[a._v("_x")]),a._v("的指令是复制栈顶数据并压入栈顶。包括两个指令，"),_("code",[a._v("dup")]),a._v("和"),_("code",[a._v("dup2")]),a._v("。 "),_("code",[a._v("dup")]),a._v("的系数代表要复制的"),_("code",[a._v("Slot")]),a._v("个数。\n"),_("code",[a._v("dup")]),a._v("开头的指令用于复制1个"),_("code",[a._v("Slot")]),a._v("的数据。例如1个"),_("code",[a._v("int")]),a._v("或1个"),_("code",[a._v("reference")]),a._v("类型数据\n"),_("code",[a._v("dup2")]),a._v("开头的指令用于复制2个"),_("code",[a._v("Slot")]),a._v("的数据。例如1个"),_("code",[a._v("long")]),a._v("，或2个"),_("code",[a._v("int")]),a._v("， 或1个"),_("code",[a._v("int+1")]),a._v("个。"),_("code",[a._v("float")]),a._v("类型数据")])]),a._v(" "),_("li",[_("p",[a._v("带"),_("code",[a._v("_x")]),a._v("的指令是复制栈顶数据并插入栈顶以下的某个位置。 共有4个指令,"),_("code",[a._v("dup_x1")]),a._v(", "),_("code",[a._v("dup2_x1")]),a._v(","),_("code",[a._v("dup_x2")]),a._v(", "),_("code",[a._v("dup2_x2")]),a._v("。 对于带"),_("code",[a._v("_x")]),a._v("的复制插入指令，只要将指令的"),_("code",[a._v("dup")]),a._v("和"),_("code",[a._v("x")]),a._v("的系数相加，结果即为需要插入的位置。因此\n"),_("code",[a._v("dup_x1")]),a._v("插入位置: "),_("code",[a._v("1+1=2")]),a._v("， 即栈顶2个"),_("code",[a._v("Slot")]),a._v("下面\n"),_("code",[a._v("dup_x2")]),a._v("插入位置: "),_("code",[a._v("1+2=3")]),a._v("，即栈项3个"),_("code",[a._v("Slot")]),a._v("下面\n"),_("code",[a._v("dup2_x1")]),a._v("插入位置: "),_("code",[a._v("2+1=3")]),a._v("， 即栈顶3个"),_("code",[a._v("Slot")]),a._v(" 下面\n"),_("code",[a._v("dup2_x2")]),a._v("插入位置: "),_("code",[a._v("2+2=4")]),a._v("， 即栈顶4个"),_("code",[a._v("Slot")]),a._v("下面")])]),a._v(" "),_("li",[_("p",[_("code",[a._v("pop")]),a._v(", 将栈顶的1个"),_("code",[a._v("Slot")]),a._v("数值出栈。例如1个"),_("code",[a._v("short")]),a._v("类型数值")])]),a._v(" "),_("li",[_("p",[_("code",[a._v("pop2")]),a._v(", 将栈顶的2个"),_("code",[a._v("Slot")]),a._v("数值 出栈。例如1个"),_("code",[a._v("double")]),a._v("类型数值， 或者2个"),_("code",[a._v("int")]),a._v("类型 数值")])])]),a._v(" "),_("h2",{attrs:{id:"八、控制转移指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#八、控制转移指令"}},[a._v("#")]),a._v(" 八、控制转移指令")]),a._v(" "),_("p",[a._v("程序流程离不开条件控制，为了支持条件跳转,虚拟机提供了大量字节码指令，大体上可以分为\n1)比较指令、2)条件跳转指令、3)比较条件跳转指令、4)多条件分支跳转指令、5)无条件跳转指令等。")]),a._v(" "),_("h3",{attrs:{id:"_8-1-条件跳转指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-条件跳转指令"}},[a._v("#")]),a._v(" 8.1 条件跳转指令")]),a._v(" "),_("p",[a._v("条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。\n条件跳转指令有: "),_("code",[a._v("ifeq， iflt, ifle，ifne，ifgt，ifge，ifnull, ifnonnull")]),a._v("。这些指令都接收两个字节的操作数，用于计算跳转的位置(16位符号整数作为当前位置的"),_("code",[a._v("offset")]),a._v(")。\n它们的统一含义为:弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/356b39f86edb4a548340dd4a12e9f174.png",alt:"image-20210328115808872"}})]),a._v(" "),_("p",[a._v("注意:")]),a._v(" "),_("ol",[_("li",[a._v("与前面运算规则一致:\n"),_("ul",[_("li",[a._v("对于"),_("code",[a._v("boolean、byte、char、short")]),a._v("类型的条件分支比较操作，都是使用"),_("code",[a._v("int")]),a._v("类型的比较指令完成")]),a._v(" "),_("li",[a._v("对于"),_("code",[a._v("long、float、double")]),a._v("类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行"),_("code",[a._v("int")]),a._v("类型的条件分支比较操作来完成整个分支跳转")])])]),a._v(" "),_("li",[a._v("由于各类型的比较最终都会转为"),_("code",[a._v("int")]),a._v("类型的比较操作，所以"),_("code",[a._v("Java")]),a._v("虚拟机提供的"),_("code",[a._v("int")]),a._v("类型的条件分支指令是最为丰富和强大的")])]),a._v(" "),_("h3",{attrs:{id:"_8-2-比较条件跳转指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-比较条件跳转指令"}},[a._v("#")]),a._v(" 8.2 比较条件跳转指令")]),a._v(" "),_("p",[a._v("比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。\n这类指令有："),_("code",[a._v("if_icmpeq、 if_icmpne、 if_icmplt、if_icmpgt、 if_icmple、if_icmpge、 if_acmpeq")]),a._v("和"),_("code",[a._v("if_acmpne")]),a._v("。其中指令助记符加上“if_”后，以字符“i”开头的指令针对"),_("code",[a._v("int")]),a._v("型整数操作(也包括"),_("code",[a._v("short")]),a._v("和"),_("code",[a._v("byte")]),a._v("类型)，以字符“a”开头的指令表示对象引用的比较。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/ed586265066a46d28de4a6640bdaf535.png",alt:"image-20210328120121521"}})]),a._v(" "),_("p",[a._v("这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。"),_("strong",[a._v("如果预设条件成立，则执行跳转，否则，继续执行下一条语句。")])]),a._v(" "),_("h3",{attrs:{id:"_8-3-多条件分支跳转"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-多条件分支跳转"}},[a._v("#")]),a._v(" 8.3 多条件分支跳转")]),a._v(" "),_("p",[a._v("多条件分支跳转指令是专为"),_("code",[a._v("switch-case")]),a._v("语句设计的，主要有"),_("code",[a._v("tableswitch")]),a._v("和"),_("code",[a._v("lookupswitch")]),a._v("。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/68afad8639b0426884b1fe3aaf8c6278.png",alt:"image-20210328120153549"}})]),a._v(" "),_("p",[a._v("从助记符上看，两者都是"),_("code",[a._v("switch")]),a._v("语句的实现，它们的区别:")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("tableswitch")]),a._v("要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数"),_("code",[a._v("index")]),a._v(",可以立即定位到跳转偏移量位置，因此效率比较高。")]),a._v(" "),_("li",[a._v("指令"),_("code",[a._v("lookupswitch")]),a._v("内部存放着各个离散的"),_("code",[a._v("case-offset")]),a._v("对，每次执行都要搜索全部的"),_("code",[a._v("case-offset")]),a._v("对，找到匹配的"),_("code",[a._v("case")]),a._v("值，并根据对应的"),_("code",[a._v("offset")]),a._v("计算跳转地址，因此效率较低。")])]),a._v(" "),_("p",[a._v("指令"),_("code",[a._v("tableswitch")]),a._v("的示意图如下图所示。由于"),_("code",[a._v("tableswitch")]),a._v("的"),_("code",[a._v("case")]),a._v("值是连续的，因此只需要记录最低值和最高值，以及每项对应的"),_("code",[a._v("offset")]),a._v("偏移量，根据给定的index值通过简单的计算即可直接定位到"),_("code",[a._v("offset")]),a._v("。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/45d434e6c6b24e6a874bedfbf2a23bf1.png",alt:"image-20210328120221226"}})]),a._v(" "),_("p",[a._v("指令"),_("code",[a._v("lookupswitch")]),a._v("处理的是离散的"),_("code",[a._v("case")]),a._v("值，但是出于效率考虑，将"),_("code",[a._v("case-offset")]),a._v("对按照"),_("code",[a._v("case")]),a._v("值大小排序，给定"),_("code",[a._v("index")]),a._v("时，需要 查找与"),_("code",[a._v("index")]),a._v("相等的"),_("code",[a._v("case")]),a._v(",获得其"),_("code",[a._v("offset")]),a._v(",如果找不到则跳转到"),_("code",[a._v("default")]),a._v("。指令"),_("code",[a._v("lookupswitch")]),a._v("如下图所示。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/62eb343ecc0345638bbc437c136d3553.png",alt:"image-20210328120233913"}})]),a._v(" "),_("h3",{attrs:{id:"_8-4-无条件跳转"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-无条件跳转"}},[a._v("#")]),a._v(" 8.4 无条件跳转")]),a._v(" "),_("p",[a._v("目前主要的无条件跳转指令为"),_("code",[a._v("goto")]),a._v("。指令"),_("code",[a._v("goto")]),a._v("接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。")]),a._v(" "),_("p",[a._v("如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令"),_("code",[a._v("goto_w")]),a._v(", 它和"),_("code",[a._v("goto")]),a._v("有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围。")]),a._v(" "),_("p",[a._v("指令"),_("code",[a._v("jsr、jsr_w、ret")]),a._v("虽然也是无条件跳转的，但主要用于"),_("code",[a._v("try-finally")]),a._v("语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/803972ba6e42423b879a5a8262af6570.png",alt:"image-20210328120349795"}})]),a._v(" "),_("h2",{attrs:{id:"九、异常处理指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#九、异常处理指令"}},[a._v("#")]),a._v(" 九、异常处理指令")]),a._v(" "),_("h3",{attrs:{id:"_9-1-抛出异常指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-抛出异常指令"}},[a._v("#")]),a._v(" 9.1 抛出异常指令")]),a._v(" "),_("ol",[_("li",[_("p",[_("code",[a._v("athrow")]),a._v("指令\n在"),_("code",[a._v("Java")]),a._v("程序中显示抛出异常的操作("),_("code",[a._v("throw")]),a._v("语句)都是由"),_("code",[a._v("athrow")]),a._v("指令来实现。（a引用类型）\n除了使用"),_("code",[a._v("throw")]),a._v("语句显示抛出异常情况之外，"),_("code",[a._v("JVM")]),a._v("规范还规定了许多运行时异常会在其他"),_("code",[a._v("Java")]),a._v("虚拟机指令检测到异常状况时自动抛出（字节码文件中看不到抛异常的指令）。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在"),_("code",[a._v("idiv")]),a._v("或 "),_("code",[a._v("idiv")]),a._v("指令中抛出"),_("code",[a._v("ArithmeticException")]),a._v("异常。")])]),a._v(" "),_("li",[_("p",[a._v("注意\n正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，"),_("code",[a._v("Java")]),a._v(" 虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。")])])]),a._v(" "),_("p",[a._v("复习：\n异常及异常的处理:\n过程一：异常对象的生成过程—> "),_("code",[a._v("throw")]),a._v(" (手动/自动) —> 指令: "),_("code",[a._v("athrow")]),a._v("\n过程二：异常的处理:抓抛模型。"),_("code",[a._v("try-catch-finally")]),a._v(" —>使用异常表")]),a._v(" "),_("h3",{attrs:{id:"_9-2-异常处理与异常表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-异常处理与异常表"}},[a._v("#")]),a._v(" 9.2 异常处理与异常表")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("处理异常\n在Java虚拟机中，处理异常(catch语句)不是由字节码指令来实现的(早期使用jsr、ret指令) ，而是采用异常表来完成的。")])]),a._v(" "),_("li",[_("p",[a._v("异常表\n如果一个方法定义了一个"),_("code",[a._v("try-catch")]),a._v("或者"),_("code",[a._v("try-finally")]),a._v("的异常处理，就会创建-一个异常表。它包含了每个异常处理或者"),_("code",[a._v("finally")]),a._v("块的信息。异常表保存了每个异常处理信息。比如:")]),a._v(" "),_("ul",[_("li",[a._v("起始位置")]),a._v(" "),_("li",[a._v("结束位置")]),a._v(" "),_("li",[a._v("程序计数器记录的代码处理的偏移地址")]),a._v(" "),_("li",[a._v("被捕获的异常类在常量池中的索引")])])])]),a._v(" "),_("p",[a._v("当一个异常被抛出时，"),_("code",[a._v("JVM")]),a._v("会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致"),_("code",[a._v("JVM")]),a._v("自已终止，比如这个线程是个"),_("code",[a._v("main")]),a._v("线程。")]),a._v(" "),_("p",[a._v("不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行"),_("code",[a._v("finally")]),a._v("块， 在"),_("code",[a._v("return")]),a._v("前， 它直接跳到"),_("code",[a._v("finally")]),a._v("块来完成目标")]),a._v(" "),_("h3",{attrs:{id:"_9-3-面试题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-面试题"}},[a._v("#")]),a._v(" 9.3 面试题")]),a._v(" "),_("p",[a._v("//思考：如下方法返回结果为多少？")]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("func")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" str "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[a._v('"hello"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("try")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" str"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("finally")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        str "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[a._v('"java"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),_("p",[a._v("返回结果：hello\n程序是顺序执行的，先走try/catch,再走finally。当try和catch中有return时，finally仍然会执行；")]),a._v(" "),_("p",[a._v("如果finally中有return,则程序会走finally中的return；如果没有，则执行try中的return时,会将return的结果先存入临时变量中(此时不会结束方法)，然后再执行finally语句，最后return临时变量中的值。(这里的值指的是String字符串和基本数据类型，如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值)")]),a._v(" "),_("p",[a._v("下面这个代码，打印结果是3")]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("func")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("try")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),a._v("a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("     "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//a=2，++a是会执行的，只是不会return")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("finally")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        a"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("       "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//a=3")]),a._v("\n         "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("func")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),_("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//a=3")]),a._v("\n")])])]),_("p",[a._v("了解完以上，面试相关已经无压力了。有兴趣想了解更多的请看帖子http://blog.csdn.net/ns_code/article/details/17485221\n实际开发中不要在finally中写return语句，")]),a._v(" "),_("h2",{attrs:{id:"十、同步控制指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十、同步控制指令"}},[a._v("#")]),a._v(" 十、同步控制指令")]),a._v(" "),_("h3",{attrs:{id:"_10-1-方法级的同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-方法级的同步"}},[a._v("#")]),a._v(" 10.1 方法级的同步")]),a._v(" "),_("p",[_("strong",[a._v("方法级的同步:是隐式的")]),a._v("，"),_("strong",[a._v("即无须通过字节码指令来控制")]),a._v("，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的"),_("code",[a._v("ACC_SYNCHRONIZED")]),a._v("访问标志得知一个方法是否声明为同步方法;")]),a._v(" "),_("p",[a._v("当调用方法时，调用指令将会检查方法的"),_("code",[a._v("ACC_SYNCHRONIZED")]),a._v("访问标志是否设置。")]),a._v(" "),_("ul",[_("li",[a._v("如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成(无论是正常完成还是非正常完成)时释放同步锁。")]),a._v(" "),_("li",[a._v("在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。")]),a._v(" "),_("li",[a._v("如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。")])]),a._v(" "),_("p",[a._v("举例：")]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("add")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    i"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),_("p",[a._v("对应的字节码")]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" aload_0\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" dup\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" getfield #"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("com"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("atguigu"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("java1"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SynchronizedTest")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("i"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" iconst_1\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v(" iadd\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("7")]),a._v(" putfield #"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("com"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("atguigu"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("java1"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SynchronizedTest")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("i"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v("\n")])])]),_("p",[a._v("说明:\n这段代码和普通的无同步操作的代码没有什么不同，没有使用"),_("code",[a._v("monitorenter")]),a._v("和"),_("code",[a._v("monitorexit")]),a._v("进行同步区控制。这是因为，对于同步方法而言，当虚拟机通过方法的访问标示符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，"),_("code",[a._v("monitorenter")]),a._v("和"),_("code",[a._v("monitorexit")]),a._v("指令是隐式存在的，并未直接出现在字节码中。")]),a._v(" "),_("h3",{attrs:{id:"_10-2-方法内指定指令序列的同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-方法内指定指令序列的同步"}},[a._v("#")]),a._v(" 10.2 方法内指定指令序列的同步")]),a._v(" "),_("p",[a._v("同步一段指令集序列：通常是由"),_("code",[a._v("Java")]),a._v("中的"),_("code",[a._v("synchronized")]),a._v("语句块来表示的。jvm的指令集有"),_("code",[a._v("monitorenter")]),a._v("和"),_("code",[a._v("monitorexit")]),a._v("两条指令来支持"),_("code",[a._v("synchronized")]),a._v("关键字的语义")]),a._v(" "),_("p",[a._v("当一个线程进入同步代码块时，它使用"),_("code",[a._v("monitorenter")]),a._v("指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块")]),a._v(" "),_("p",[a._v("当线程退出同步块时，需要使用"),_("code",[a._v("monitorexit")]),a._v("声明退出。在"),_("code",[a._v("Java")]),a._v("虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有时，对象处于锁定状态\n指令"),_("code",[a._v("monitorenter")]),a._v("和"),_("code",[a._v("monitorexit")]),a._v("在执行时，都需要在操作数栈顶压入对象，之后"),_("code",[a._v("monitorenter")]),a._v("和"),_("code",[a._v("monitorexit")]),a._v("的锁定和释放都是针对这个对象的监视器进行的\n下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程4离开临界区后，线程1、2、3才有可能进入。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/b2bf8334bf7041ac8e32faa75b52c025.png",alt:"image-20210328121248160"}})]),a._v(" "),_("p",[a._v("举例：")]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("subtract")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        i"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),_("p",[a._v("字节码指令：")]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" aload_0\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" getfield #"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("com"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("atguigu"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("java1"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SynchronizedTest")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("obj"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v(" dup\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" astore_1\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v(" monitorenter\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("7")]),a._v(" aload_0\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),a._v(" dup\n "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("9")]),a._v(" getfield #"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("com"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("atguigu"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("java1"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SynchronizedTest")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("i"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),a._v(" iconst_1\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("13")]),a._v(" isub\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("14")]),a._v(" putfield #"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("com"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("atguigu"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("java1"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SynchronizedTest")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("i"),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("17")]),a._v(" aload_1\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("18")]),a._v(" monitorexit\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("19")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("goto")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("27")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("22")]),a._v(" astore_2\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("23")]),a._v(" aload_1\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("24")]),a._v(" monitorexit\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("25")]),a._v(" aload_2\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("26")]),a._v(" athrow\n"),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("27")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v("\n")])])]),_("p",[a._v("异常表：")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://you-blog.oss-accelerate.aliyuncs.com/typora/2021-03-28/b4c5d8f4c3a847bc82f87feeb4ee100b.png",alt:"image-20210328121344792"}})]),a._v(" "),_("p",[a._v("编译器必须确保无论方法通过何种方式完成，方法中调用过的每条"),_("code",[a._v("monitorenter")]),a._v("指令都必须执行其对应的"),_("code",[a._v("monitorexit")]),a._v("指令，而无论这个方法是正常结束还是异常结束。\n为了保证在方法异常完成时"),_("code",[a._v("monitorenter")]),a._v("和"),_("code",[a._v("monitorexit")]),a._v("指令依然可以正确配对执行，"),_("strong",[a._v("编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令")])])])}),[],!1,null,null,null);t.default=s.exports}}]);